{"ast":null,"code":"import { parser } from '@lezer/javascript';\nimport { syntaxTree, LRLanguage, indentNodeProp, continuedIndent, flatIndent, delimitedIndent, foldNodeProp, foldInside, defineLanguageFacet, sublanguageProp, LanguageSupport } from '@codemirror/language';\nimport { EditorSelection } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\n\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/\nconst snippets = [/*@__PURE__*/snippetCompletion(\"function ${name}(${params}) {\\n\\t${}\\n}\", {\n  label: \"function\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\\t${}\\n}\", {\n  label: \"for\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"for (let ${name} of ${collection}) {\\n\\t${}\\n}\", {\n  label: \"for\",\n  detail: \"of loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"do {\\n\\t${}\\n} while (${})\", {\n  label: \"do\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"while (${}) {\\n\\t${}\\n}\", {\n  label: \"while\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"try {\\n\\t${}\\n} catch (${error}) {\\n\\t${}\\n}\", {\n  label: \"try\",\n  detail: \"/ catch block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n}\", {\n  label: \"if\",\n  detail: \"block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n} else {\\n\\t${}\\n}\", {\n  label: \"if\",\n  detail: \"/ else block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"class ${name} {\\n\\tconstructor(${params}) {\\n\\t\\t${}\\n\\t}\\n}\", {\n  label: \"class\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"import {${names}} from \\\"${module}\\\"\\n${}\", {\n  label: \"import\",\n  detail: \"named\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"import ${name} from \\\"${module}\\\"\\n${}\", {\n  label: \"import\",\n  detail: \"default\",\n  type: \"keyword\"\n})];\nconst cache = /*@__PURE__*/new NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\"Script\", \"Block\", \"FunctionExpression\", \"FunctionDeclaration\", \"ArrowFunction\", \"MethodDeclaration\", \"ForStatement\"]);\nfunction defID(type) {\n  return (node, def) => {\n    let id = node.node.getChild(\"VariableDefinition\");\n    if (id) def(id, type);\n    return true;\n  };\n}\nconst functionContext = [\"FunctionDeclaration\"];\nconst gatherCompletions = {\n  FunctionDeclaration: /*@__PURE__*/defID(\"function\"),\n  ClassDeclaration: /*@__PURE__*/defID(\"class\"),\n  ClassExpression: () => true,\n  EnumDeclaration: /*@__PURE__*/defID(\"constant\"),\n  TypeAliasDeclaration: /*@__PURE__*/defID(\"type\"),\n  NamespaceDeclaration: /*@__PURE__*/defID(\"namespace\"),\n  VariableDefinition(node, def) {\n    if (!node.matchContext(functionContext)) def(node, \"variable\");\n  },\n  TypeDefinition(node, def) {\n    def(node, \"type\");\n  },\n  __proto__: null\n};\nfunction getScope(doc, node) {\n  let cached = cache.get(node);\n  if (cached) return cached;\n  let completions = [],\n    top = true;\n  function def(node, type) {\n    let name = doc.sliceString(node.from, node.to);\n    completions.push({\n      label: name,\n      type\n    });\n  }\n  node.cursor(IterMode.IncludeAnonymous).iterate(node => {\n    if (top) {\n      top = false;\n    } else if (node.name) {\n      let gather = gatherCompletions[node.name];\n      if (gather && gather(node, def) || ScopeNodes.has(node.name)) return false;\n    } else if (node.to - node.from > 8192) {\n      // Allow caching for bigger internal nodes\n      for (let c of getScope(doc, node.node)) completions.push(c);\n      return false;\n    }\n  });\n  cache.set(node, completions);\n  return completions;\n}\nconst Identifier = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\"TemplateString\", \"String\", \"RegExp\", \"LineComment\", \"BlockComment\", \"VariableDefinition\", \"TypeDefinition\", \"Label\", \"PropertyDefinition\", \"PropertyName\", \"PrivatePropertyDefinition\", \"PrivatePropertyName\", \".\", \"?.\"];\n/**\nCompletion source that looks up locally defined names in\nJavaScript code.\n*/\nfunction localCompletionSource(context) {\n  let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n  if (dontComplete.indexOf(inner.name) > -1) return null;\n  let isWord = inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n  if (!isWord && !context.explicit) return null;\n  let options = [];\n  for (let pos = inner; pos; pos = pos.parent) {\n    if (ScopeNodes.has(pos.name)) options = options.concat(getScope(context.state.doc, pos));\n  }\n  return {\n    options,\n    from: isWord ? inner.from : context.pos,\n    validFor: Identifier\n  };\n}\nfunction pathFor(read, member, name) {\n  var _a;\n  let path = [];\n  for (;;) {\n    let obj = member.firstChild,\n      prop;\n    if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"VariableName\") {\n      path.push(read(obj));\n      return {\n        path: path.reverse(),\n        name\n      };\n    } else if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"MemberExpression\" && ((_a = prop = obj.lastChild) === null || _a === void 0 ? void 0 : _a.name) == \"PropertyName\") {\n      path.push(read(prop));\n      member = obj;\n    } else {\n      return null;\n    }\n  }\n}\n/**\nHelper function for defining JavaScript completion sources. It\nreturns the completable name and object path for a completion\ncontext, or null if no name/property completion should happen at\nthat position. For example, when completing after `a.b.c` it will\nreturn `{path: [\"a\", \"b\"], name: \"c\"}`. When completing after `x`\nit will return `{path: [], name: \"x\"}`. When not in a property or\nname, it will return null if `context.explicit` is false, and\n`{path: [], name: \"\"}` otherwise.\n*/\nfunction completionPath(context) {\n  let read = node => context.state.doc.sliceString(node.from, node.to);\n  let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n  if (inner.name == \"PropertyName\") {\n    return pathFor(read, inner.parent, read(inner));\n  } else if ((inner.name == \".\" || inner.name == \"?.\") && inner.parent.name == \"MemberExpression\") {\n    return pathFor(read, inner.parent, \"\");\n  } else if (dontComplete.indexOf(inner.name) > -1) {\n    return null;\n  } else if (inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {\n    return {\n      path: [],\n      name: read(inner)\n    };\n  } else if (inner.name == \"MemberExpression\") {\n    return pathFor(read, inner, \"\");\n  } else {\n    return context.explicit ? {\n      path: [],\n      name: \"\"\n    } : null;\n  }\n}\nfunction enumeratePropertyCompletions(obj, top) {\n  let options = [],\n    seen = new Set();\n  for (let depth = 0;; depth++) {\n    for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)) {\n      if (seen.has(name)) continue;\n      seen.add(name);\n      let value;\n      try {\n        value = obj[name];\n      } catch (_) {\n        continue;\n      }\n      options.push({\n        label: name,\n        type: typeof value == \"function\" ? /^[A-Z]/.test(name) ? \"class\" : top ? \"function\" : \"method\" : top ? \"variable\" : \"property\",\n        boost: -depth\n      });\n    }\n    let next = Object.getPrototypeOf(obj);\n    if (!next) return options;\n    obj = next;\n  }\n}\n/**\nDefines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that\ncompletes from the given scope object (for example `globalThis`).\nWill enter properties of the object when completing properties on\na directly-named path.\n*/\nfunction scopeCompletionSource(scope) {\n  let cache = new Map();\n  return context => {\n    let path = completionPath(context);\n    if (!path) return null;\n    let target = scope;\n    for (let step of path.path) {\n      target = target[step];\n      if (!target) return null;\n    }\n    let options = cache.get(target);\n    if (!options) cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));\n    return {\n      from: context.pos - path.name.length,\n      options,\n      validFor: Identifier\n    };\n  };\n}\n\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/\nconst javascriptLanguage = /*@__PURE__*/LRLanguage.define({\n  name: \"javascript\",\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      IfStatement: /*@__PURE__*/continuedIndent({\n        except: /^\\s*({|else\\b)/\n      }),\n      TryStatement: /*@__PURE__*/continuedIndent({\n        except: /^\\s*({|catch\\b|finally\\b)/\n      }),\n      LabeledStatement: flatIndent,\n      SwitchBody: context => {\n        let after = context.textAfter,\n          closed = /^\\s*\\}/.test(after),\n          isCase = /^\\s*(case|default)\\b/.test(after);\n        return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n      },\n      Block: /*@__PURE__*/delimitedIndent({\n        closing: \"}\"\n      }),\n      ArrowFunction: cx => cx.baseIndent + cx.unit,\n      \"TemplateString BlockComment\": () => null,\n      \"Statement Property\": /*@__PURE__*/continuedIndent({\n        except: /^{/\n      }),\n      JSXElement(context) {\n        let closed = /^\\s*<\\//.test(context.textAfter);\n        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n      },\n      JSXEscape(context) {\n        let closed = /\\s*\\}/.test(context.textAfter);\n        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n      },\n      \"JSXOpenTag JSXSelfClosingTag\"(context) {\n        return context.column(context.node.from) + context.unit;\n      }\n    }), /*@__PURE__*/foldNodeProp.add({\n      \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": foldInside,\n      BlockComment(tree) {\n        return {\n          from: tree.from + 2,\n          to: tree.to - 2\n        };\n      }\n    })]\n  }),\n  languageData: {\n    closeBrackets: {\n      brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"]\n    },\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    },\n    indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n    wordChars: \"$\"\n  }\n});\nconst jsxSublanguage = {\n  test: node => /^JSX/.test(node.name),\n  facet: /*@__PURE__*/defineLanguageFacet({\n    commentTokens: {\n      block: {\n        open: \"{/*\",\n        close: \"*/}\"\n      }\n    }\n  })\n};\n/**\nA language provider for TypeScript.\n*/\nconst typescriptLanguage = /*@__PURE__*/javascriptLanguage.configure({\n  dialect: \"ts\"\n}, \"typescript\");\n/**\nLanguage provider for JSX.\n*/\nconst jsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n  dialect: \"jsx\",\n  props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/\nconst tsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n  dialect: \"jsx ts\",\n  props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n}, \"typescript\");\nconst keywords = /*@__PURE__*/\"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(kw => ({\n  label: kw,\n  type: \"keyword\"\n}));\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\ncompletion.\n*/\nfunction javascript() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let lang = config.jsx ? config.typescript ? tsxLanguage : jsxLanguage : config.typescript ? typescriptLanguage : javascriptLanguage;\n  return new LanguageSupport(lang, [javascriptLanguage.data.of({\n    autocomplete: ifNotIn(dontComplete, completeFromList(snippets.concat(keywords)))\n  }), javascriptLanguage.data.of({\n    autocomplete: localCompletionSource\n  }), config.jsx ? autoCloseTags : []]);\n}\nfunction findOpenTag(node) {\n  for (;;) {\n    if (node.name == \"JSXOpenTag\" || node.name == \"JSXSelfClosingTag\" || node.name == \"JSXFragmentTag\") return node;\n    if (node.name == \"JSXEscape\" || !node.parent) return null;\n    node = node.parent;\n  }\n}\nfunction elementName(doc, tree) {\n  let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : doc.length;\n  for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {\n    if (ch.name == \"JSXIdentifier\" || ch.name == \"JSXBuiltin\" || ch.name == \"JSXNamespacedName\" || ch.name == \"JSXMemberExpression\") return doc.sliceString(ch.from, Math.min(ch.to, max));\n  }\n  return \"\";\n}\nfunction isEndTag(node) {\n  return node && (node.name == \"JSXEndTag\" || node.name == \"JSXSelfCloseEndTag\");\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*/ /Android\\b/.test(navigator.userAgent);\n/**\nExtension that will automatically insert JSX close tags when a `>` or\n`/` is typed.\n*/\nconst autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, text) => {\n  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly || from != to || text != \">\" && text != \"/\" || !javascriptLanguage.isActiveAt(view.state, from, -1)) return false;\n  let {\n    state\n  } = view;\n  let changes = state.changeByRange(range => {\n    var _a;\n    let {\n        head\n      } = range,\n      around = syntaxTree(state).resolveInner(head, -1),\n      name;\n    if (around.name == \"JSXStartTag\") around = around.parent;\n    if (around.name == \"JSXAttributeValue\" && around.to > head) ;else if (text == \">\" && around.name == \"JSXFragmentTag\") {\n      return {\n        range: EditorSelection.cursor(head + 1),\n        changes: {\n          from: head,\n          insert: `></>`\n        }\n      };\n    } else if (text == \"/\" && around.name == \"JSXFragmentTag\") {\n      let empty = around.parent,\n        base = empty === null || empty === void 0 ? void 0 : empty.parent;\n      if (empty.from == head - 1 && ((_a = base.lastChild) === null || _a === void 0 ? void 0 : _a.name) != \"JSXEndTag\" && (name = elementName(state.doc, base === null || base === void 0 ? void 0 : base.firstChild, head))) {\n        let insert = `/${name}>`;\n        return {\n          range: EditorSelection.cursor(head + insert.length),\n          changes: {\n            from: head,\n            insert\n          }\n        };\n      }\n    } else if (text == \">\") {\n      let openTag = findOpenTag(around);\n      if (openTag && !isEndTag(openTag.lastChild) && state.sliceDoc(head, head + 2) != \"</\" && (name = elementName(state.doc, openTag, head))) return {\n        range: EditorSelection.cursor(head + 1),\n        changes: {\n          from: head,\n          insert: `></${name}>`\n        }\n      };\n    }\n    return {\n      range\n    };\n  });\n  if (changes.changes.empty) return false;\n  view.dispatch(changes, {\n    userEvent: \"input.type\",\n    scrollIntoView: true\n  });\n  return true;\n});\n\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The\n[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)\npackage may help with that (see\n[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).\n*/\nfunction esLint(eslint, config) {\n  if (!config) {\n    config = {\n      parserOptions: {\n        ecmaVersion: 2019,\n        sourceType: \"module\"\n      },\n      env: {\n        browser: true,\n        node: true,\n        es6: true,\n        es2015: true,\n        es2017: true,\n        es2020: true\n      },\n      rules: {}\n    };\n    eslint.getRules().forEach((desc, name) => {\n      if (desc.meta.docs.recommended) config.rules[name] = 2;\n    });\n  }\n  return view => {\n    let {\n        state\n      } = view,\n      found = [];\n    for (let {\n      from,\n      to\n    } of javascriptLanguage.findRegions(state)) {\n      let fromLine = state.doc.lineAt(from),\n        offset = {\n          line: fromLine.number - 1,\n          col: from - fromLine.from,\n          pos: from\n        };\n      for (let d of eslint.verify(state.sliceDoc(from, to), config)) found.push(translateDiagnostic(d, state.doc, offset));\n    }\n    return found;\n  };\n}\nfunction mapPos(line, col, doc, offset) {\n  return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\nfunction translateDiagnostic(input, doc, offset) {\n  let start = mapPos(input.line, input.column, doc, offset);\n  let result = {\n    from: start,\n    to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n    message: input.message,\n    source: input.ruleId ? \"eslint:\" + input.ruleId : \"eslint\",\n    severity: input.severity == 1 ? \"warning\" : \"error\"\n  };\n  if (input.fix) {\n    let {\n        range,\n        text\n      } = input.fix,\n      from = range[0] + offset.pos - start,\n      to = range[1] + offset.pos - start;\n    result.actions = [{\n      name: \"fix\",\n      apply(view, start) {\n        view.dispatch({\n          changes: {\n            from: start + from,\n            to: start + to,\n            insert: text\n          },\n          scrollIntoView: true\n        });\n      }\n    }];\n  }\n  return result;\n}\nexport { autoCloseTags, completionPath, esLint, javascript, javascriptLanguage, jsxLanguage, localCompletionSource, scopeCompletionSource, snippets, tsxLanguage, typescriptLanguage };","map":{"version":3,"names":["parser","syntaxTree","LRLanguage","indentNodeProp","continuedIndent","flatIndent","delimitedIndent","foldNodeProp","foldInside","defineLanguageFacet","sublanguageProp","LanguageSupport","EditorSelection","EditorView","snippetCompletion","ifNotIn","completeFromList","NodeWeakMap","IterMode","snippets","label","detail","type","cache","ScopeNodes","Set","defID","node","def","id","getChild","functionContext","gatherCompletions","FunctionDeclaration","ClassDeclaration","ClassExpression","EnumDeclaration","TypeAliasDeclaration","NamespaceDeclaration","VariableDefinition","matchContext","TypeDefinition","__proto__","getScope","doc","cached","get","completions","top","name","sliceString","from","to","push","cursor","IncludeAnonymous","iterate","gather","has","c","set","Identifier","dontComplete","localCompletionSource","context","inner","state","resolveInner","pos","indexOf","isWord","test","sliceDoc","explicit","options","parent","concat","validFor","pathFor","read","member","_a","path","obj","firstChild","prop","reverse","lastChild","completionPath","enumeratePropertyCompletions","seen","depth","Object","getOwnPropertyNames","keys","add","value","_","boost","next","getPrototypeOf","scopeCompletionSource","scope","Map","target","step","length","javascriptLanguage","define","configure","props","IfStatement","except","TryStatement","LabeledStatement","SwitchBody","after","textAfter","closed","isCase","baseIndent","unit","Block","closing","ArrowFunction","cx","TemplateString BlockComment","JSXElement","lineIndent","JSXEscape","JSXOpenTag JSXSelfClosingTag","column","BlockComment","tree","languageData","closeBrackets","brackets","commentTokens","line","block","open","close","indentOnInput","wordChars","jsxSublanguage","facet","typescriptLanguage","dialect","jsxLanguage","n","isTop","undefined","tsxLanguage","keywords","split","map","kw","javascript","config","arguments","lang","jsx","typescript","data","of","autocomplete","autoCloseTags","findOpenTag","elementName","max","ch","nextSibling","Math","min","isEndTag","android","navigator","userAgent","inputHandler","view","text","composing","compositionStarted","readOnly","isActiveAt","changes","changeByRange","range","head","around","insert","empty","base","openTag","dispatch","userEvent","scrollIntoView","esLint","eslint","parserOptions","ecmaVersion","sourceType","env","browser","es6","es2015","es2017","es2020","rules","getRules","forEach","desc","meta","docs","recommended","found","findRegions","fromLine","lineAt","offset","number","col","d","verify","translateDiagnostic","mapPos","input","start","result","endLine","endColumn","message","source","ruleId","severity","fix","actions","apply"],"sources":["/Users/adityapethe/Developer/ui-chat/ui-chat/client/node_modules/@codemirror/lang-javascript/dist/index.js"],"sourcesContent":["import { parser } from '@lezer/javascript';\nimport { syntaxTree, LRLanguage, indentNodeProp, continuedIndent, flatIndent, delimitedIndent, foldNodeProp, foldInside, defineLanguageFacet, sublanguageProp, LanguageSupport } from '@codemirror/language';\nimport { EditorSelection } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\n\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/\nconst snippets = [\n    /*@__PURE__*/snippetCompletion(\"function ${name}(${params}) {\\n\\t${}\\n}\", {\n        label: \"function\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for (let ${name} of ${collection}) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"of loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"do {\\n\\t${}\\n} while (${})\", {\n        label: \"do\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"while (${}) {\\n\\t${}\\n}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"try {\\n\\t${}\\n} catch (${error}) {\\n\\t${}\\n}\", {\n        label: \"try\",\n        detail: \"/ catch block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n} else {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"class ${name} {\\n\\tconstructor(${params}) {\\n\\t\\t${}\\n\\t}\\n}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import {${names}} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"named\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import ${name} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"default\",\n        type: \"keyword\"\n    })\n];\n\nconst cache = /*@__PURE__*/new NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\n    \"Script\", \"Block\",\n    \"FunctionExpression\", \"FunctionDeclaration\", \"ArrowFunction\", \"MethodDeclaration\",\n    \"ForStatement\"\n]);\nfunction defID(type) {\n    return (node, def) => {\n        let id = node.node.getChild(\"VariableDefinition\");\n        if (id)\n            def(id, type);\n        return true;\n    };\n}\nconst functionContext = [\"FunctionDeclaration\"];\nconst gatherCompletions = {\n    FunctionDeclaration: /*@__PURE__*/defID(\"function\"),\n    ClassDeclaration: /*@__PURE__*/defID(\"class\"),\n    ClassExpression: () => true,\n    EnumDeclaration: /*@__PURE__*/defID(\"constant\"),\n    TypeAliasDeclaration: /*@__PURE__*/defID(\"type\"),\n    NamespaceDeclaration: /*@__PURE__*/defID(\"namespace\"),\n    VariableDefinition(node, def) { if (!node.matchContext(functionContext))\n        def(node, \"variable\"); },\n    TypeDefinition(node, def) { def(node, \"type\"); },\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached)\n        return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({ label: name, type });\n    }\n    node.cursor(IterMode.IncludeAnonymous).iterate(node => {\n        if (top) {\n            top = false;\n        }\n        else if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def) || ScopeNodes.has(node.name))\n                return false;\n        }\n        else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))\n                completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\n    \"TemplateString\", \"String\", \"RegExp\",\n    \"LineComment\", \"BlockComment\",\n    \"VariableDefinition\", \"TypeDefinition\", \"Label\",\n    \"PropertyDefinition\", \"PropertyName\",\n    \"PrivatePropertyDefinition\", \"PrivatePropertyName\",\n    \".\", \"?.\"\n];\n/**\nCompletion source that looks up locally defined names in\nJavaScript code.\n*/\nfunction localCompletionSource(context) {\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1)\n        return null;\n    let isWord = inner.name == \"VariableName\" ||\n        inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit)\n        return null;\n    let options = [];\n    for (let pos = inner; pos; pos = pos.parent) {\n        if (ScopeNodes.has(pos.name))\n            options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nfunction pathFor(read, member, name) {\n    var _a;\n    let path = [];\n    for (;;) {\n        let obj = member.firstChild, prop;\n        if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"VariableName\") {\n            path.push(read(obj));\n            return { path: path.reverse(), name };\n        }\n        else if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"MemberExpression\" && ((_a = (prop = obj.lastChild)) === null || _a === void 0 ? void 0 : _a.name) == \"PropertyName\") {\n            path.push(read(prop));\n            member = obj;\n        }\n        else {\n            return null;\n        }\n    }\n}\n/**\nHelper function for defining JavaScript completion sources. It\nreturns the completable name and object path for a completion\ncontext, or null if no name/property completion should happen at\nthat position. For example, when completing after `a.b.c` it will\nreturn `{path: [\"a\", \"b\"], name: \"c\"}`. When completing after `x`\nit will return `{path: [], name: \"x\"}`. When not in a property or\nname, it will return null if `context.explicit` is false, and\n`{path: [], name: \"\"}` otherwise.\n*/\nfunction completionPath(context) {\n    let read = (node) => context.state.doc.sliceString(node.from, node.to);\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (inner.name == \"PropertyName\") {\n        return pathFor(read, inner.parent, read(inner));\n    }\n    else if ((inner.name == \".\" || inner.name == \"?.\") && inner.parent.name == \"MemberExpression\") {\n        return pathFor(read, inner.parent, \"\");\n    }\n    else if (dontComplete.indexOf(inner.name) > -1) {\n        return null;\n    }\n    else if (inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {\n        return { path: [], name: read(inner) };\n    }\n    else if (inner.name == \"MemberExpression\") {\n        return pathFor(read, inner, \"\");\n    }\n    else {\n        return context.explicit ? { path: [], name: \"\" } : null;\n    }\n}\nfunction enumeratePropertyCompletions(obj, top) {\n    let options = [], seen = new Set;\n    for (let depth = 0;; depth++) {\n        for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)) {\n            if (seen.has(name))\n                continue;\n            seen.add(name);\n            let value;\n            try {\n                value = obj[name];\n            }\n            catch (_) {\n                continue;\n            }\n            options.push({\n                label: name,\n                type: typeof value == \"function\" ? (/^[A-Z]/.test(name) ? \"class\" : top ? \"function\" : \"method\")\n                    : top ? \"variable\" : \"property\",\n                boost: -depth\n            });\n        }\n        let next = Object.getPrototypeOf(obj);\n        if (!next)\n            return options;\n        obj = next;\n    }\n}\n/**\nDefines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that\ncompletes from the given scope object (for example `globalThis`).\nWill enter properties of the object when completing properties on\na directly-named path.\n*/\nfunction scopeCompletionSource(scope) {\n    let cache = new Map;\n    return (context) => {\n        let path = completionPath(context);\n        if (!path)\n            return null;\n        let target = scope;\n        for (let step of path.path) {\n            target = target[step];\n            if (!target)\n                return null;\n        }\n        let options = cache.get(target);\n        if (!options)\n            cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));\n        return {\n            from: context.pos - path.name.length,\n            options,\n            validFor: Identifier\n        };\n    };\n}\n\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/\nconst javascriptLanguage = /*@__PURE__*/LRLanguage.define({\n    name: \"javascript\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                IfStatement: /*@__PURE__*/continuedIndent({ except: /^\\s*({|else\\b)/ }),\n                TryStatement: /*@__PURE__*/continuedIndent({ except: /^\\s*({|catch\\b|finally\\b)/ }),\n                LabeledStatement: flatIndent,\n                SwitchBody: context => {\n                    let after = context.textAfter, closed = /^\\s*\\}/.test(after), isCase = /^\\s*(case|default)\\b/.test(after);\n                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n                },\n                Block: /*@__PURE__*/delimitedIndent({ closing: \"}\" }),\n                ArrowFunction: cx => cx.baseIndent + cx.unit,\n                \"TemplateString BlockComment\": () => null,\n                \"Statement Property\": /*@__PURE__*/continuedIndent({ except: /^{/ }),\n                JSXElement(context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                JSXEscape(context) {\n                    let closed = /\\s*\\}/.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                \"JSXOpenTag JSXSelfClosingTag\"(context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": foldInside,\n                BlockComment(tree) { return { from: tree.from + 2, to: tree.to - 2 }; }\n            })\n        ]\n    }),\n    languageData: {\n        closeBrackets: { brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"] },\n        commentTokens: { line: \"//\", block: { open: \"/*\", close: \"*/\" } },\n        indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n        wordChars: \"$\"\n    }\n});\nconst jsxSublanguage = {\n    test: node => /^JSX/.test(node.name),\n    facet: /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: \"{/*\", close: \"*/}\" } } })\n};\n/**\nA language provider for TypeScript.\n*/\nconst typescriptLanguage = /*@__PURE__*/javascriptLanguage.configure({ dialect: \"ts\" }, \"typescript\");\n/**\nLanguage provider for JSX.\n*/\nconst jsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx\",\n    props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/\nconst tsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx ts\",\n    props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n}, \"typescript\");\nconst keywords = /*@__PURE__*/\"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(kw => ({ label: kw, type: \"keyword\" }));\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\ncompletion.\n*/\nfunction javascript(config = {}) {\n    let lang = config.jsx ? (config.typescript ? tsxLanguage : jsxLanguage)\n        : config.typescript ? typescriptLanguage : javascriptLanguage;\n    return new LanguageSupport(lang, [\n        javascriptLanguage.data.of({\n            autocomplete: ifNotIn(dontComplete, completeFromList(snippets.concat(keywords)))\n        }),\n        javascriptLanguage.data.of({\n            autocomplete: localCompletionSource\n        }),\n        config.jsx ? autoCloseTags : [],\n    ]);\n}\nfunction findOpenTag(node) {\n    for (;;) {\n        if (node.name == \"JSXOpenTag\" || node.name == \"JSXSelfClosingTag\" || node.name == \"JSXFragmentTag\")\n            return node;\n        if (node.name == \"JSXEscape\" || !node.parent)\n            return null;\n        node = node.parent;\n    }\n}\nfunction elementName(doc, tree, max = doc.length) {\n    for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {\n        if (ch.name == \"JSXIdentifier\" || ch.name == \"JSXBuiltin\" || ch.name == \"JSXNamespacedName\" ||\n            ch.name == \"JSXMemberExpression\")\n            return doc.sliceString(ch.from, Math.min(ch.to, max));\n    }\n    return \"\";\n}\nfunction isEndTag(node) {\n    return node && (node.name == \"JSXEndTag\" || node.name == \"JSXSelfCloseEndTag\");\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*//Android\\b/.test(navigator.userAgent);\n/**\nExtension that will automatically insert JSX close tags when a `>` or\n`/` is typed.\n*/\nconst autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, text) => {\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly ||\n        from != to || (text != \">\" && text != \"/\") ||\n        !javascriptLanguage.isActiveAt(view.state, from, -1))\n        return false;\n    let { state } = view;\n    let changes = state.changeByRange(range => {\n        var _a;\n        let { head } = range, around = syntaxTree(state).resolveInner(head, -1), name;\n        if (around.name == \"JSXStartTag\")\n            around = around.parent;\n        if (around.name == \"JSXAttributeValue\" && around.to > head) ;\n        else if (text == \">\" && around.name == \"JSXFragmentTag\") {\n            return { range: EditorSelection.cursor(head + 1), changes: { from: head, insert: `></>` } };\n        }\n        else if (text == \"/\" && around.name == \"JSXFragmentTag\") {\n            let empty = around.parent, base = empty === null || empty === void 0 ? void 0 : empty.parent;\n            if (empty.from == head - 1 && ((_a = base.lastChild) === null || _a === void 0 ? void 0 : _a.name) != \"JSXEndTag\" &&\n                (name = elementName(state.doc, base === null || base === void 0 ? void 0 : base.firstChild, head))) {\n                let insert = `/${name}>`;\n                return { range: EditorSelection.cursor(head + insert.length), changes: { from: head, insert } };\n            }\n        }\n        else if (text == \">\") {\n            let openTag = findOpenTag(around);\n            if (openTag && !isEndTag(openTag.lastChild) &&\n                state.sliceDoc(head, head + 2) != \"</\" &&\n                (name = elementName(state.doc, openTag, head)))\n                return { range: EditorSelection.cursor(head + 1), changes: { from: head, insert: `></${name}>` } };\n        }\n        return { range };\n    });\n    if (changes.changes.empty)\n        return false;\n    view.dispatch(changes, { userEvent: \"input.type\", scrollIntoView: true });\n    return true;\n});\n\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The\n[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)\npackage may help with that (see\n[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).\n*/\nfunction esLint(eslint, config) {\n    if (!config) {\n        config = {\n            parserOptions: { ecmaVersion: 2019, sourceType: \"module\" },\n            env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },\n            rules: {}\n        };\n        eslint.getRules().forEach((desc, name) => {\n            if (desc.meta.docs.recommended)\n                config.rules[name] = 2;\n        });\n    }\n    return (view) => {\n        let { state } = view, found = [];\n        for (let { from, to } of javascriptLanguage.findRegions(state)) {\n            let fromLine = state.doc.lineAt(from), offset = { line: fromLine.number - 1, col: from - fromLine.from, pos: from };\n            for (let d of eslint.verify(state.sliceDoc(from, to), config))\n                found.push(translateDiagnostic(d, state.doc, offset));\n        }\n        return found;\n    };\n}\nfunction mapPos(line, col, doc, offset) {\n    return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\nfunction translateDiagnostic(input, doc, offset) {\n    let start = mapPos(input.line, input.column, doc, offset);\n    let result = {\n        from: start,\n        to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n        message: input.message,\n        source: input.ruleId ? \"eslint:\" + input.ruleId : \"eslint\",\n        severity: input.severity == 1 ? \"warning\" : \"error\",\n    };\n    if (input.fix) {\n        let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;\n        result.actions = [{\n                name: \"fix\",\n                apply(view, start) {\n                    view.dispatch({ changes: { from: start + from, to: start + to, insert: text }, scrollIntoView: true });\n                }\n            }];\n    }\n    return result;\n}\n\nexport { autoCloseTags, completionPath, esLint, javascript, javascriptLanguage, jsxLanguage, localCompletionSource, scopeCompletionSource, snippets, tsxLanguage, typescriptLanguage };\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,mBAAmB;AAC1C,SAASC,UAAU,EAAEC,UAAU,EAAEC,cAAc,EAAEC,eAAe,EAAEC,UAAU,EAAEC,eAAe,EAAEC,YAAY,EAAEC,UAAU,EAAEC,mBAAmB,EAAEC,eAAe,EAAEC,eAAe,QAAQ,sBAAsB;AAC5M,SAASC,eAAe,QAAQ,mBAAmB;AACnD,SAASC,UAAU,QAAQ,kBAAkB;AAC7C,SAASC,iBAAiB,EAAEC,OAAO,EAAEC,gBAAgB,QAAQ,0BAA0B;AACvF,SAASC,WAAW,EAAEC,QAAQ,QAAQ,eAAe;;AAErD;AACA;AACA;AACA;AACA,MAAMC,QAAQ,GAAG,CACb,aAAaL,iBAAiB,CAAC,yCAAyC,EAAE;EACtEM,KAAK,EAAE,UAAU;EACjBC,MAAM,EAAE,YAAY;EACpBC,IAAI,EAAE;AACV,CAAC,CAAC,EACF,aAAaR,iBAAiB,CAAC,qEAAqE,EAAE;EAClGM,KAAK,EAAE,KAAK;EACZC,MAAM,EAAE,MAAM;EACdC,IAAI,EAAE;AACV,CAAC,CAAC,EACF,aAAaR,iBAAiB,CAAC,gDAAgD,EAAE;EAC7EM,KAAK,EAAE,KAAK;EACZC,MAAM,EAAE,SAAS;EACjBC,IAAI,EAAE;AACV,CAAC,CAAC,EACF,aAAaR,iBAAiB,CAAC,4BAA4B,EAAE;EACzDM,KAAK,EAAE,IAAI;EACXC,MAAM,EAAE,MAAM;EACdC,IAAI,EAAE;AACV,CAAC,CAAC,EACF,aAAaR,iBAAiB,CAAC,yBAAyB,EAAE;EACtDM,KAAK,EAAE,OAAO;EACdC,MAAM,EAAE,MAAM;EACdC,IAAI,EAAE;AACV,CAAC,CAAC,EACF,aAAaR,iBAAiB,CAAC,8CAA8C,EAAE;EAC3EM,KAAK,EAAE,KAAK;EACZC,MAAM,EAAE,eAAe;EACvBC,IAAI,EAAE;AACV,CAAC,CAAC,EACF,aAAaR,iBAAiB,CAAC,sBAAsB,EAAE;EACnDM,KAAK,EAAE,IAAI;EACXC,MAAM,EAAE,OAAO;EACfC,IAAI,EAAE;AACV,CAAC,CAAC,EACF,aAAaR,iBAAiB,CAAC,uCAAuC,EAAE;EACpEM,KAAK,EAAE,IAAI;EACXC,MAAM,EAAE,cAAc;EACtBC,IAAI,EAAE;AACV,CAAC,CAAC,EACF,aAAaR,iBAAiB,CAAC,8DAA8D,EAAE;EAC3FM,KAAK,EAAE,OAAO;EACdC,MAAM,EAAE,YAAY;EACpBC,IAAI,EAAE;AACV,CAAC,CAAC,EACF,aAAaR,iBAAiB,CAAC,2CAA2C,EAAE;EACxEM,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,OAAO;EACfC,IAAI,EAAE;AACV,CAAC,CAAC,EACF,aAAaR,iBAAiB,CAAC,wCAAwC,EAAE;EACrEM,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,SAAS;EACjBC,IAAI,EAAE;AACV,CAAC,CAAC,CACL;AAED,MAAMC,KAAK,GAAG,aAAa,IAAIN,WAAW,CAAC,CAAC;AAC5C,MAAMO,UAAU,GAAG,aAAa,IAAIC,GAAG,CAAC,CACpC,QAAQ,EAAE,OAAO,EACjB,oBAAoB,EAAE,qBAAqB,EAAE,eAAe,EAAE,mBAAmB,EACjF,cAAc,CACjB,CAAC;AACF,SAASC,KAAKA,CAACJ,IAAI,EAAE;EACjB,OAAO,CAACK,IAAI,EAAEC,GAAG,KAAK;IAClB,IAAIC,EAAE,GAAGF,IAAI,CAACA,IAAI,CAACG,QAAQ,CAAC,oBAAoB,CAAC;IACjD,IAAID,EAAE,EACFD,GAAG,CAACC,EAAE,EAAEP,IAAI,CAAC;IACjB,OAAO,IAAI;EACf,CAAC;AACL;AACA,MAAMS,eAAe,GAAG,CAAC,qBAAqB,CAAC;AAC/C,MAAMC,iBAAiB,GAAG;EACtBC,mBAAmB,EAAE,aAAaP,KAAK,CAAC,UAAU,CAAC;EACnDQ,gBAAgB,EAAE,aAAaR,KAAK,CAAC,OAAO,CAAC;EAC7CS,eAAe,EAAEA,CAAA,KAAM,IAAI;EAC3BC,eAAe,EAAE,aAAaV,KAAK,CAAC,UAAU,CAAC;EAC/CW,oBAAoB,EAAE,aAAaX,KAAK,CAAC,MAAM,CAAC;EAChDY,oBAAoB,EAAE,aAAaZ,KAAK,CAAC,WAAW,CAAC;EACrDa,kBAAkBA,CAACZ,IAAI,EAAEC,GAAG,EAAE;IAAE,IAAI,CAACD,IAAI,CAACa,YAAY,CAACT,eAAe,CAAC,EACnEH,GAAG,CAACD,IAAI,EAAE,UAAU,CAAC;EAAE,CAAC;EAC5Bc,cAAcA,CAACd,IAAI,EAAEC,GAAG,EAAE;IAAEA,GAAG,CAACD,IAAI,EAAE,MAAM,CAAC;EAAE,CAAC;EAChDe,SAAS,EAAE;AACf,CAAC;AACD,SAASC,QAAQA,CAACC,GAAG,EAAEjB,IAAI,EAAE;EACzB,IAAIkB,MAAM,GAAGtB,KAAK,CAACuB,GAAG,CAACnB,IAAI,CAAC;EAC5B,IAAIkB,MAAM,EACN,OAAOA,MAAM;EACjB,IAAIE,WAAW,GAAG,EAAE;IAAEC,GAAG,GAAG,IAAI;EAChC,SAASpB,GAAGA,CAACD,IAAI,EAAEL,IAAI,EAAE;IACrB,IAAI2B,IAAI,GAAGL,GAAG,CAACM,WAAW,CAACvB,IAAI,CAACwB,IAAI,EAAExB,IAAI,CAACyB,EAAE,CAAC;IAC9CL,WAAW,CAACM,IAAI,CAAC;MAAEjC,KAAK,EAAE6B,IAAI;MAAE3B;IAAK,CAAC,CAAC;EAC3C;EACAK,IAAI,CAAC2B,MAAM,CAACpC,QAAQ,CAACqC,gBAAgB,CAAC,CAACC,OAAO,CAAC7B,IAAI,IAAI;IACnD,IAAIqB,GAAG,EAAE;MACLA,GAAG,GAAG,KAAK;IACf,CAAC,MACI,IAAIrB,IAAI,CAACsB,IAAI,EAAE;MAChB,IAAIQ,MAAM,GAAGzB,iBAAiB,CAACL,IAAI,CAACsB,IAAI,CAAC;MACzC,IAAIQ,MAAM,IAAIA,MAAM,CAAC9B,IAAI,EAAEC,GAAG,CAAC,IAAIJ,UAAU,CAACkC,GAAG,CAAC/B,IAAI,CAACsB,IAAI,CAAC,EACxD,OAAO,KAAK;IACpB,CAAC,MACI,IAAItB,IAAI,CAACyB,EAAE,GAAGzB,IAAI,CAACwB,IAAI,GAAG,IAAI,EAAE;MACjC;MACA,KAAK,IAAIQ,CAAC,IAAIhB,QAAQ,CAACC,GAAG,EAAEjB,IAAI,CAACA,IAAI,CAAC,EAClCoB,WAAW,CAACM,IAAI,CAACM,CAAC,CAAC;MACvB,OAAO,KAAK;IAChB;EACJ,CAAC,CAAC;EACFpC,KAAK,CAACqC,GAAG,CAACjC,IAAI,EAAEoB,WAAW,CAAC;EAC5B,OAAOA,WAAW;AACtB;AACA,MAAMc,UAAU,GAAG,uCAAuC;AAC1D,MAAMC,YAAY,GAAG,CACjB,gBAAgB,EAAE,QAAQ,EAAE,QAAQ,EACpC,aAAa,EAAE,cAAc,EAC7B,oBAAoB,EAAE,gBAAgB,EAAE,OAAO,EAC/C,oBAAoB,EAAE,cAAc,EACpC,2BAA2B,EAAE,qBAAqB,EAClD,GAAG,EAAE,IAAI,CACZ;AACD;AACA;AACA;AACA;AACA,SAASC,qBAAqBA,CAACC,OAAO,EAAE;EACpC,IAAIC,KAAK,GAAGhE,UAAU,CAAC+D,OAAO,CAACE,KAAK,CAAC,CAACC,YAAY,CAACH,OAAO,CAACI,GAAG,EAAE,CAAC,CAAC,CAAC;EACnE,IAAIN,YAAY,CAACO,OAAO,CAACJ,KAAK,CAAChB,IAAI,CAAC,GAAG,CAAC,CAAC,EACrC,OAAO,IAAI;EACf,IAAIqB,MAAM,GAAGL,KAAK,CAAChB,IAAI,IAAI,cAAc,IACrCgB,KAAK,CAACb,EAAE,GAAGa,KAAK,CAACd,IAAI,GAAG,EAAE,IAAIU,UAAU,CAACU,IAAI,CAACP,OAAO,CAACE,KAAK,CAACM,QAAQ,CAACP,KAAK,CAACd,IAAI,EAAEc,KAAK,CAACb,EAAE,CAAC,CAAC;EAC/F,IAAI,CAACkB,MAAM,IAAI,CAACN,OAAO,CAACS,QAAQ,EAC5B,OAAO,IAAI;EACf,IAAIC,OAAO,GAAG,EAAE;EAChB,KAAK,IAAIN,GAAG,GAAGH,KAAK,EAAEG,GAAG,EAAEA,GAAG,GAAGA,GAAG,CAACO,MAAM,EAAE;IACzC,IAAInD,UAAU,CAACkC,GAAG,CAACU,GAAG,CAACnB,IAAI,CAAC,EACxByB,OAAO,GAAGA,OAAO,CAACE,MAAM,CAACjC,QAAQ,CAACqB,OAAO,CAACE,KAAK,CAACtB,GAAG,EAAEwB,GAAG,CAAC,CAAC;EAClE;EACA,OAAO;IACHM,OAAO;IACPvB,IAAI,EAAEmB,MAAM,GAAGL,KAAK,CAACd,IAAI,GAAGa,OAAO,CAACI,GAAG;IACvCS,QAAQ,EAAEhB;EACd,CAAC;AACL;AACA,SAASiB,OAAOA,CAACC,IAAI,EAAEC,MAAM,EAAE/B,IAAI,EAAE;EACjC,IAAIgC,EAAE;EACN,IAAIC,IAAI,GAAG,EAAE;EACb,SAAS;IACL,IAAIC,GAAG,GAAGH,MAAM,CAACI,UAAU;MAAEC,IAAI;IACjC,IAAI,CAACF,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,GAAG,CAAClC,IAAI,KAAK,cAAc,EAAE;MACxEiC,IAAI,CAAC7B,IAAI,CAAC0B,IAAI,CAACI,GAAG,CAAC,CAAC;MACpB,OAAO;QAAED,IAAI,EAAEA,IAAI,CAACI,OAAO,CAAC,CAAC;QAAErC;MAAK,CAAC;IACzC,CAAC,MACI,IAAI,CAACkC,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,GAAG,CAAClC,IAAI,KAAK,kBAAkB,IAAI,CAAC,CAACgC,EAAE,GAAII,IAAI,GAAGF,GAAG,CAACI,SAAU,MAAM,IAAI,IAAIN,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAChC,IAAI,KAAK,cAAc,EAAE;MACnLiC,IAAI,CAAC7B,IAAI,CAAC0B,IAAI,CAACM,IAAI,CAAC,CAAC;MACrBL,MAAM,GAAGG,GAAG;IAChB,CAAC,MACI;MACD,OAAO,IAAI;IACf;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,cAAcA,CAACxB,OAAO,EAAE;EAC7B,IAAIe,IAAI,GAAIpD,IAAI,IAAKqC,OAAO,CAACE,KAAK,CAACtB,GAAG,CAACM,WAAW,CAACvB,IAAI,CAACwB,IAAI,EAAExB,IAAI,CAACyB,EAAE,CAAC;EACtE,IAAIa,KAAK,GAAGhE,UAAU,CAAC+D,OAAO,CAACE,KAAK,CAAC,CAACC,YAAY,CAACH,OAAO,CAACI,GAAG,EAAE,CAAC,CAAC,CAAC;EACnE,IAAIH,KAAK,CAAChB,IAAI,IAAI,cAAc,EAAE;IAC9B,OAAO6B,OAAO,CAACC,IAAI,EAAEd,KAAK,CAACU,MAAM,EAAEI,IAAI,CAACd,KAAK,CAAC,CAAC;EACnD,CAAC,MACI,IAAI,CAACA,KAAK,CAAChB,IAAI,IAAI,GAAG,IAAIgB,KAAK,CAAChB,IAAI,IAAI,IAAI,KAAKgB,KAAK,CAACU,MAAM,CAAC1B,IAAI,IAAI,kBAAkB,EAAE;IAC3F,OAAO6B,OAAO,CAACC,IAAI,EAAEd,KAAK,CAACU,MAAM,EAAE,EAAE,CAAC;EAC1C,CAAC,MACI,IAAIb,YAAY,CAACO,OAAO,CAACJ,KAAK,CAAChB,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;IAC5C,OAAO,IAAI;EACf,CAAC,MACI,IAAIgB,KAAK,CAAChB,IAAI,IAAI,cAAc,IAAIgB,KAAK,CAACb,EAAE,GAAGa,KAAK,CAACd,IAAI,GAAG,EAAE,IAAIU,UAAU,CAACU,IAAI,CAACQ,IAAI,CAACd,KAAK,CAAC,CAAC,EAAE;IACjG,OAAO;MAAEiB,IAAI,EAAE,EAAE;MAAEjC,IAAI,EAAE8B,IAAI,CAACd,KAAK;IAAE,CAAC;EAC1C,CAAC,MACI,IAAIA,KAAK,CAAChB,IAAI,IAAI,kBAAkB,EAAE;IACvC,OAAO6B,OAAO,CAACC,IAAI,EAAEd,KAAK,EAAE,EAAE,CAAC;EACnC,CAAC,MACI;IACD,OAAOD,OAAO,CAACS,QAAQ,GAAG;MAAES,IAAI,EAAE,EAAE;MAAEjC,IAAI,EAAE;IAAG,CAAC,GAAG,IAAI;EAC3D;AACJ;AACA,SAASwC,4BAA4BA,CAACN,GAAG,EAAEnC,GAAG,EAAE;EAC5C,IAAI0B,OAAO,GAAG,EAAE;IAAEgB,IAAI,GAAG,IAAIjE,GAAG,CAAD,CAAC;EAChC,KAAK,IAAIkE,KAAK,GAAG,CAAC,GAAGA,KAAK,EAAE,EAAE;IAC1B,KAAK,IAAI1C,IAAI,IAAI,CAAC2C,MAAM,CAACC,mBAAmB,IAAID,MAAM,CAACE,IAAI,EAAEX,GAAG,CAAC,EAAE;MAC/D,IAAIO,IAAI,CAAChC,GAAG,CAACT,IAAI,CAAC,EACd;MACJyC,IAAI,CAACK,GAAG,CAAC9C,IAAI,CAAC;MACd,IAAI+C,KAAK;MACT,IAAI;QACAA,KAAK,GAAGb,GAAG,CAAClC,IAAI,CAAC;MACrB,CAAC,CACD,OAAOgD,CAAC,EAAE;QACN;MACJ;MACAvB,OAAO,CAACrB,IAAI,CAAC;QACTjC,KAAK,EAAE6B,IAAI;QACX3B,IAAI,EAAE,OAAO0E,KAAK,IAAI,UAAU,GAAI,QAAQ,CAACzB,IAAI,CAACtB,IAAI,CAAC,GAAG,OAAO,GAAGD,GAAG,GAAG,UAAU,GAAG,QAAQ,GACzFA,GAAG,GAAG,UAAU,GAAG,UAAU;QACnCkD,KAAK,EAAE,CAACP;MACZ,CAAC,CAAC;IACN;IACA,IAAIQ,IAAI,GAAGP,MAAM,CAACQ,cAAc,CAACjB,GAAG,CAAC;IACrC,IAAI,CAACgB,IAAI,EACL,OAAOzB,OAAO;IAClBS,GAAG,GAAGgB,IAAI;EACd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,qBAAqBA,CAACC,KAAK,EAAE;EAClC,IAAI/E,KAAK,GAAG,IAAIgF,GAAG,CAAD,CAAC;EACnB,OAAQvC,OAAO,IAAK;IAChB,IAAIkB,IAAI,GAAGM,cAAc,CAACxB,OAAO,CAAC;IAClC,IAAI,CAACkB,IAAI,EACL,OAAO,IAAI;IACf,IAAIsB,MAAM,GAAGF,KAAK;IAClB,KAAK,IAAIG,IAAI,IAAIvB,IAAI,CAACA,IAAI,EAAE;MACxBsB,MAAM,GAAGA,MAAM,CAACC,IAAI,CAAC;MACrB,IAAI,CAACD,MAAM,EACP,OAAO,IAAI;IACnB;IACA,IAAI9B,OAAO,GAAGnD,KAAK,CAACuB,GAAG,CAAC0D,MAAM,CAAC;IAC/B,IAAI,CAAC9B,OAAO,EACRnD,KAAK,CAACqC,GAAG,CAAC4C,MAAM,EAAE9B,OAAO,GAAGe,4BAA4B,CAACe,MAAM,EAAE,CAACtB,IAAI,CAACA,IAAI,CAACwB,MAAM,CAAC,CAAC;IACxF,OAAO;MACHvD,IAAI,EAAEa,OAAO,CAACI,GAAG,GAAGc,IAAI,CAACjC,IAAI,CAACyD,MAAM;MACpChC,OAAO;MACPG,QAAQ,EAAEhB;IACd,CAAC;EACL,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM8C,kBAAkB,GAAG,aAAazG,UAAU,CAAC0G,MAAM,CAAC;EACtD3D,IAAI,EAAE,YAAY;EAClBjD,MAAM,EAAE,aAAaA,MAAM,CAAC6G,SAAS,CAAC;IAClCC,KAAK,EAAE,CACH,aAAa3G,cAAc,CAAC4F,GAAG,CAAC;MAC5BgB,WAAW,EAAE,aAAa3G,eAAe,CAAC;QAAE4G,MAAM,EAAE;MAAiB,CAAC,CAAC;MACvEC,YAAY,EAAE,aAAa7G,eAAe,CAAC;QAAE4G,MAAM,EAAE;MAA4B,CAAC,CAAC;MACnFE,gBAAgB,EAAE7G,UAAU;MAC5B8G,UAAU,EAAEnD,OAAO,IAAI;QACnB,IAAIoD,KAAK,GAAGpD,OAAO,CAACqD,SAAS;UAAEC,MAAM,GAAG,QAAQ,CAAC/C,IAAI,CAAC6C,KAAK,CAAC;UAAEG,MAAM,GAAG,sBAAsB,CAAChD,IAAI,CAAC6C,KAAK,CAAC;QACzG,OAAOpD,OAAO,CAACwD,UAAU,GAAG,CAACF,MAAM,GAAG,CAAC,GAAGC,MAAM,GAAG,CAAC,GAAG,CAAC,IAAIvD,OAAO,CAACyD,IAAI;MAC5E,CAAC;MACDC,KAAK,EAAE,aAAapH,eAAe,CAAC;QAAEqH,OAAO,EAAE;MAAI,CAAC,CAAC;MACrDC,aAAa,EAAEC,EAAE,IAAIA,EAAE,CAACL,UAAU,GAAGK,EAAE,CAACJ,IAAI;MAC5C,6BAA6B,EAAEK,CAAA,KAAM,IAAI;MACzC,oBAAoB,EAAE,aAAa1H,eAAe,CAAC;QAAE4G,MAAM,EAAE;MAAK,CAAC,CAAC;MACpEe,UAAUA,CAAC/D,OAAO,EAAE;QAChB,IAAIsD,MAAM,GAAG,SAAS,CAAC/C,IAAI,CAACP,OAAO,CAACqD,SAAS,CAAC;QAC9C,OAAOrD,OAAO,CAACgE,UAAU,CAAChE,OAAO,CAACrC,IAAI,CAACwB,IAAI,CAAC,IAAImE,MAAM,GAAG,CAAC,GAAGtD,OAAO,CAACyD,IAAI,CAAC;MAC9E,CAAC;MACDQ,SAASA,CAACjE,OAAO,EAAE;QACf,IAAIsD,MAAM,GAAG,OAAO,CAAC/C,IAAI,CAACP,OAAO,CAACqD,SAAS,CAAC;QAC5C,OAAOrD,OAAO,CAACgE,UAAU,CAAChE,OAAO,CAACrC,IAAI,CAACwB,IAAI,CAAC,IAAImE,MAAM,GAAG,CAAC,GAAGtD,OAAO,CAACyD,IAAI,CAAC;MAC9E,CAAC;MACD,8BAA8BS,CAAClE,OAAO,EAAE;QACpC,OAAOA,OAAO,CAACmE,MAAM,CAACnE,OAAO,CAACrC,IAAI,CAACwB,IAAI,CAAC,GAAGa,OAAO,CAACyD,IAAI;MAC3D;IACJ,CAAC,CAAC,EACF,aAAalH,YAAY,CAACwF,GAAG,CAAC;MAC1B,iFAAiF,EAAEvF,UAAU;MAC7F4H,YAAYA,CAACC,IAAI,EAAE;QAAE,OAAO;UAAElF,IAAI,EAAEkF,IAAI,CAAClF,IAAI,GAAG,CAAC;UAAEC,EAAE,EAAEiF,IAAI,CAACjF,EAAE,GAAG;QAAE,CAAC;MAAE;IAC1E,CAAC,CAAC;EAEV,CAAC,CAAC;EACFkF,YAAY,EAAE;IACVC,aAAa,EAAE;MAAEC,QAAQ,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;IAAE,CAAC;IAC3DC,aAAa,EAAE;MAAEC,IAAI,EAAE,IAAI;MAAEC,KAAK,EAAE;QAAEC,IAAI,EAAE,IAAI;QAAEC,KAAK,EAAE;MAAK;IAAE,CAAC;IACjEC,aAAa,EAAE,mCAAmC;IAClDC,SAAS,EAAE;EACf;AACJ,CAAC,CAAC;AACF,MAAMC,cAAc,GAAG;EACnBzE,IAAI,EAAE5C,IAAI,IAAI,MAAM,CAAC4C,IAAI,CAAC5C,IAAI,CAACsB,IAAI,CAAC;EACpCgG,KAAK,EAAE,aAAaxI,mBAAmB,CAAC;IAAEgI,aAAa,EAAE;MAAEE,KAAK,EAAE;QAAEC,IAAI,EAAE,KAAK;QAAEC,KAAK,EAAE;MAAM;IAAE;EAAE,CAAC;AACvG,CAAC;AACD;AACA;AACA;AACA,MAAMK,kBAAkB,GAAG,aAAavC,kBAAkB,CAACE,SAAS,CAAC;EAAEsC,OAAO,EAAE;AAAK,CAAC,EAAE,YAAY,CAAC;AACrG;AACA;AACA;AACA,MAAMC,WAAW,GAAG,aAAazC,kBAAkB,CAACE,SAAS,CAAC;EAC1DsC,OAAO,EAAE,KAAK;EACdrC,KAAK,EAAE,CAAC,aAAapG,eAAe,CAACqF,GAAG,CAACsD,CAAC,IAAIA,CAAC,CAACC,KAAK,GAAG,CAACN,cAAc,CAAC,GAAGO,SAAS,CAAC;AACzF,CAAC,CAAC;AACF;AACA;AACA;AACA,MAAMC,WAAW,GAAG,aAAa7C,kBAAkB,CAACE,SAAS,CAAC;EAC1DsC,OAAO,EAAE,QAAQ;EACjBrC,KAAK,EAAE,CAAC,aAAapG,eAAe,CAACqF,GAAG,CAACsD,CAAC,IAAIA,CAAC,CAACC,KAAK,GAAG,CAACN,cAAc,CAAC,GAAGO,SAAS,CAAC;AACzF,CAAC,EAAE,YAAY,CAAC;AAChB,MAAME,QAAQ,GAAG,aAAa,yJAAyJ,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,EAAE,KAAK;EAAExI,KAAK,EAAEwI,EAAE;EAAEtI,IAAI,EAAE;AAAU,CAAC,CAAC,CAAC;AAC9O;AACA;AACA;AACA;AACA,SAASuI,UAAUA,CAAA,EAAc;EAAA,IAAbC,MAAM,GAAAC,SAAA,CAAArD,MAAA,QAAAqD,SAAA,QAAAR,SAAA,GAAAQ,SAAA,MAAG,CAAC,CAAC;EAC3B,IAAIC,IAAI,GAAGF,MAAM,CAACG,GAAG,GAAIH,MAAM,CAACI,UAAU,GAAGV,WAAW,GAAGJ,WAAW,GAChEU,MAAM,CAACI,UAAU,GAAGhB,kBAAkB,GAAGvC,kBAAkB;EACjE,OAAO,IAAIhG,eAAe,CAACqJ,IAAI,EAAE,CAC7BrD,kBAAkB,CAACwD,IAAI,CAACC,EAAE,CAAC;IACvBC,YAAY,EAAEtJ,OAAO,CAAC+C,YAAY,EAAE9C,gBAAgB,CAACG,QAAQ,CAACyD,MAAM,CAAC6E,QAAQ,CAAC,CAAC;EACnF,CAAC,CAAC,EACF9C,kBAAkB,CAACwD,IAAI,CAACC,EAAE,CAAC;IACvBC,YAAY,EAAEtG;EAClB,CAAC,CAAC,EACF+F,MAAM,CAACG,GAAG,GAAGK,aAAa,GAAG,EAAE,CAClC,CAAC;AACN;AACA,SAASC,WAAWA,CAAC5I,IAAI,EAAE;EACvB,SAAS;IACL,IAAIA,IAAI,CAACsB,IAAI,IAAI,YAAY,IAAItB,IAAI,CAACsB,IAAI,IAAI,mBAAmB,IAAItB,IAAI,CAACsB,IAAI,IAAI,gBAAgB,EAC9F,OAAOtB,IAAI;IACf,IAAIA,IAAI,CAACsB,IAAI,IAAI,WAAW,IAAI,CAACtB,IAAI,CAACgD,MAAM,EACxC,OAAO,IAAI;IACfhD,IAAI,GAAGA,IAAI,CAACgD,MAAM;EACtB;AACJ;AACA,SAAS6F,WAAWA,CAAC5H,GAAG,EAAEyF,IAAI,EAAoB;EAAA,IAAlBoC,GAAG,GAAAV,SAAA,CAAArD,MAAA,QAAAqD,SAAA,QAAAR,SAAA,GAAAQ,SAAA,MAAGnH,GAAG,CAAC8D,MAAM;EAC5C,KAAK,IAAIgE,EAAE,GAAGrC,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACjD,UAAU,EAAEsF,EAAE,EAAEA,EAAE,GAAGA,EAAE,CAACC,WAAW,EAAE;IAChG,IAAID,EAAE,CAACzH,IAAI,IAAI,eAAe,IAAIyH,EAAE,CAACzH,IAAI,IAAI,YAAY,IAAIyH,EAAE,CAACzH,IAAI,IAAI,mBAAmB,IACvFyH,EAAE,CAACzH,IAAI,IAAI,qBAAqB,EAChC,OAAOL,GAAG,CAACM,WAAW,CAACwH,EAAE,CAACvH,IAAI,EAAEyH,IAAI,CAACC,GAAG,CAACH,EAAE,CAACtH,EAAE,EAAEqH,GAAG,CAAC,CAAC;EAC7D;EACA,OAAO,EAAE;AACb;AACA,SAASK,QAAQA,CAACnJ,IAAI,EAAE;EACpB,OAAOA,IAAI,KAAKA,IAAI,CAACsB,IAAI,IAAI,WAAW,IAAItB,IAAI,CAACsB,IAAI,IAAI,oBAAoB,CAAC;AAClF;AACA,MAAM8H,OAAO,GAAG,OAAOC,SAAS,IAAI,QAAQ,IAAI,aAAa,YAAW,CAACzG,IAAI,CAACyG,SAAS,CAACC,SAAS,CAAC;AAClG;AACA;AACA;AACA;AACA,MAAMX,aAAa,GAAG,aAAazJ,UAAU,CAACqK,YAAY,CAACd,EAAE,CAAC,CAACe,IAAI,EAAEhI,IAAI,EAAEC,EAAE,EAAEgI,IAAI,KAAK;EACpF,IAAI,CAACL,OAAO,GAAGI,IAAI,CAACE,SAAS,GAAGF,IAAI,CAACG,kBAAkB,KAAKH,IAAI,CAACjH,KAAK,CAACqH,QAAQ,IAC3EpI,IAAI,IAAIC,EAAE,IAAKgI,IAAI,IAAI,GAAG,IAAIA,IAAI,IAAI,GAAI,IAC1C,CAACzE,kBAAkB,CAAC6E,UAAU,CAACL,IAAI,CAACjH,KAAK,EAAEf,IAAI,EAAE,CAAC,CAAC,CAAC,EACpD,OAAO,KAAK;EAChB,IAAI;IAAEe;EAAM,CAAC,GAAGiH,IAAI;EACpB,IAAIM,OAAO,GAAGvH,KAAK,CAACwH,aAAa,CAACC,KAAK,IAAI;IACvC,IAAI1G,EAAE;IACN,IAAI;QAAE2G;MAAK,CAAC,GAAGD,KAAK;MAAEE,MAAM,GAAG5L,UAAU,CAACiE,KAAK,CAAC,CAACC,YAAY,CAACyH,IAAI,EAAE,CAAC,CAAC,CAAC;MAAE3I,IAAI;IAC7E,IAAI4I,MAAM,CAAC5I,IAAI,IAAI,aAAa,EAC5B4I,MAAM,GAAGA,MAAM,CAAClH,MAAM;IAC1B,IAAIkH,MAAM,CAAC5I,IAAI,IAAI,mBAAmB,IAAI4I,MAAM,CAACzI,EAAE,GAAGwI,IAAI,EAAE,CAAC,KACxD,IAAIR,IAAI,IAAI,GAAG,IAAIS,MAAM,CAAC5I,IAAI,IAAI,gBAAgB,EAAE;MACrD,OAAO;QAAE0I,KAAK,EAAE/K,eAAe,CAAC0C,MAAM,CAACsI,IAAI,GAAG,CAAC,CAAC;QAAEH,OAAO,EAAE;UAAEtI,IAAI,EAAEyI,IAAI;UAAEE,MAAM,EAAG;QAAM;MAAE,CAAC;IAC/F,CAAC,MACI,IAAIV,IAAI,IAAI,GAAG,IAAIS,MAAM,CAAC5I,IAAI,IAAI,gBAAgB,EAAE;MACrD,IAAI8I,KAAK,GAAGF,MAAM,CAAClH,MAAM;QAAEqH,IAAI,GAAGD,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAACpH,MAAM;MAC5F,IAAIoH,KAAK,CAAC5I,IAAI,IAAIyI,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC3G,EAAE,GAAG+G,IAAI,CAACzG,SAAS,MAAM,IAAI,IAAIN,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAChC,IAAI,KAAK,WAAW,KAC5GA,IAAI,GAAGuH,WAAW,CAACtG,KAAK,CAACtB,GAAG,EAAEoJ,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAAC5G,UAAU,EAAEwG,IAAI,CAAC,CAAC,EAAE;QACpG,IAAIE,MAAM,GAAI,IAAG7I,IAAK,GAAE;QACxB,OAAO;UAAE0I,KAAK,EAAE/K,eAAe,CAAC0C,MAAM,CAACsI,IAAI,GAAGE,MAAM,CAACpF,MAAM,CAAC;UAAE+E,OAAO,EAAE;YAAEtI,IAAI,EAAEyI,IAAI;YAAEE;UAAO;QAAE,CAAC;MACnG;IACJ,CAAC,MACI,IAAIV,IAAI,IAAI,GAAG,EAAE;MAClB,IAAIa,OAAO,GAAG1B,WAAW,CAACsB,MAAM,CAAC;MACjC,IAAII,OAAO,IAAI,CAACnB,QAAQ,CAACmB,OAAO,CAAC1G,SAAS,CAAC,IACvCrB,KAAK,CAACM,QAAQ,CAACoH,IAAI,EAAEA,IAAI,GAAG,CAAC,CAAC,IAAI,IAAI,KACrC3I,IAAI,GAAGuH,WAAW,CAACtG,KAAK,CAACtB,GAAG,EAAEqJ,OAAO,EAAEL,IAAI,CAAC,CAAC,EAC9C,OAAO;QAAED,KAAK,EAAE/K,eAAe,CAAC0C,MAAM,CAACsI,IAAI,GAAG,CAAC,CAAC;QAAEH,OAAO,EAAE;UAAEtI,IAAI,EAAEyI,IAAI;UAAEE,MAAM,EAAG,MAAK7I,IAAK;QAAG;MAAE,CAAC;IAC1G;IACA,OAAO;MAAE0I;IAAM,CAAC;EACpB,CAAC,CAAC;EACF,IAAIF,OAAO,CAACA,OAAO,CAACM,KAAK,EACrB,OAAO,KAAK;EAChBZ,IAAI,CAACe,QAAQ,CAACT,OAAO,EAAE;IAAEU,SAAS,EAAE,YAAY;IAAEC,cAAc,EAAE;EAAK,CAAC,CAAC;EACzE,OAAO,IAAI;AACf,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAACC,MAAM,EAAExC,MAAM,EAAE;EAC5B,IAAI,CAACA,MAAM,EAAE;IACTA,MAAM,GAAG;MACLyC,aAAa,EAAE;QAAEC,WAAW,EAAE,IAAI;QAAEC,UAAU,EAAE;MAAS,CAAC;MAC1DC,GAAG,EAAE;QAAEC,OAAO,EAAE,IAAI;QAAEhL,IAAI,EAAE,IAAI;QAAEiL,GAAG,EAAE,IAAI;QAAEC,MAAM,EAAE,IAAI;QAAEC,MAAM,EAAE,IAAI;QAAEC,MAAM,EAAE;MAAK,CAAC;MACvFC,KAAK,EAAE,CAAC;IACZ,CAAC;IACDV,MAAM,CAACW,QAAQ,CAAC,CAAC,CAACC,OAAO,CAAC,CAACC,IAAI,EAAElK,IAAI,KAAK;MACtC,IAAIkK,IAAI,CAACC,IAAI,CAACC,IAAI,CAACC,WAAW,EAC1BxD,MAAM,CAACkD,KAAK,CAAC/J,IAAI,CAAC,GAAG,CAAC;IAC9B,CAAC,CAAC;EACN;EACA,OAAQkI,IAAI,IAAK;IACb,IAAI;QAAEjH;MAAM,CAAC,GAAGiH,IAAI;MAAEoC,KAAK,GAAG,EAAE;IAChC,KAAK,IAAI;MAAEpK,IAAI;MAAEC;IAAG,CAAC,IAAIuD,kBAAkB,CAAC6G,WAAW,CAACtJ,KAAK,CAAC,EAAE;MAC5D,IAAIuJ,QAAQ,GAAGvJ,KAAK,CAACtB,GAAG,CAAC8K,MAAM,CAACvK,IAAI,CAAC;QAAEwK,MAAM,GAAG;UAAEjF,IAAI,EAAE+E,QAAQ,CAACG,MAAM,GAAG,CAAC;UAAEC,GAAG,EAAE1K,IAAI,GAAGsK,QAAQ,CAACtK,IAAI;UAAEiB,GAAG,EAAEjB;QAAK,CAAC;MACnH,KAAK,IAAI2K,CAAC,IAAIxB,MAAM,CAACyB,MAAM,CAAC7J,KAAK,CAACM,QAAQ,CAACrB,IAAI,EAAEC,EAAE,CAAC,EAAE0G,MAAM,CAAC,EACzDyD,KAAK,CAAClK,IAAI,CAAC2K,mBAAmB,CAACF,CAAC,EAAE5J,KAAK,CAACtB,GAAG,EAAE+K,MAAM,CAAC,CAAC;IAC7D;IACA,OAAOJ,KAAK;EAChB,CAAC;AACL;AACA,SAASU,MAAMA,CAACvF,IAAI,EAAEmF,GAAG,EAAEjL,GAAG,EAAE+K,MAAM,EAAE;EACpC,OAAO/K,GAAG,CAAC8F,IAAI,CAACA,IAAI,GAAGiF,MAAM,CAACjF,IAAI,CAAC,CAACvF,IAAI,GAAG0K,GAAG,IAAInF,IAAI,IAAI,CAAC,GAAGiF,MAAM,CAACE,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AACtF;AACA,SAASG,mBAAmBA,CAACE,KAAK,EAAEtL,GAAG,EAAE+K,MAAM,EAAE;EAC7C,IAAIQ,KAAK,GAAGF,MAAM,CAACC,KAAK,CAACxF,IAAI,EAAEwF,KAAK,CAAC/F,MAAM,EAAEvF,GAAG,EAAE+K,MAAM,CAAC;EACzD,IAAIS,MAAM,GAAG;IACTjL,IAAI,EAAEgL,KAAK;IACX/K,EAAE,EAAE8K,KAAK,CAACG,OAAO,IAAI,IAAI,IAAIH,KAAK,CAACI,SAAS,IAAI,CAAC,GAAGL,MAAM,CAACC,KAAK,CAACG,OAAO,EAAEH,KAAK,CAACI,SAAS,EAAE1L,GAAG,EAAE+K,MAAM,CAAC,GAAGQ,KAAK;IAC/GI,OAAO,EAAEL,KAAK,CAACK,OAAO;IACtBC,MAAM,EAAEN,KAAK,CAACO,MAAM,GAAG,SAAS,GAAGP,KAAK,CAACO,MAAM,GAAG,QAAQ;IAC1DC,QAAQ,EAAER,KAAK,CAACQ,QAAQ,IAAI,CAAC,GAAG,SAAS,GAAG;EAChD,CAAC;EACD,IAAIR,KAAK,CAACS,GAAG,EAAE;IACX,IAAI;QAAEhD,KAAK;QAAEP;MAAK,CAAC,GAAG8C,KAAK,CAACS,GAAG;MAAExL,IAAI,GAAGwI,KAAK,CAAC,CAAC,CAAC,GAAGgC,MAAM,CAACvJ,GAAG,GAAG+J,KAAK;MAAE/K,EAAE,GAAGuI,KAAK,CAAC,CAAC,CAAC,GAAGgC,MAAM,CAACvJ,GAAG,GAAG+J,KAAK;IACzGC,MAAM,CAACQ,OAAO,GAAG,CAAC;MACV3L,IAAI,EAAE,KAAK;MACX4L,KAAKA,CAAC1D,IAAI,EAAEgD,KAAK,EAAE;QACfhD,IAAI,CAACe,QAAQ,CAAC;UAAET,OAAO,EAAE;YAAEtI,IAAI,EAAEgL,KAAK,GAAGhL,IAAI;YAAEC,EAAE,EAAE+K,KAAK,GAAG/K,EAAE;YAAE0I,MAAM,EAAEV;UAAK,CAAC;UAAEgB,cAAc,EAAE;QAAK,CAAC,CAAC;MAC1G;IACJ,CAAC,CAAC;EACV;EACA,OAAOgC,MAAM;AACjB;AAEA,SAAS9D,aAAa,EAAE9E,cAAc,EAAE6G,MAAM,EAAExC,UAAU,EAAElD,kBAAkB,EAAEyC,WAAW,EAAErF,qBAAqB,EAAEsC,qBAAqB,EAAElF,QAAQ,EAAEqI,WAAW,EAAEN,kBAAkB"},"metadata":{},"sourceType":"module","externalDependencies":[]}