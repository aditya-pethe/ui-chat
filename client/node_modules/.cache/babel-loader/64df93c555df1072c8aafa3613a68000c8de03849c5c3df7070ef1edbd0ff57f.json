{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/adityapethe/Developer/ui-chat/ui-chat/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { parser } from '@lezer/javascript';\nimport { syntaxTree, LRLanguage, indentNodeProp, continuedIndent, flatIndent, delimitedIndent, foldNodeProp, foldInside, defineLanguageFacet, sublanguageProp, LanguageSupport } from '@codemirror/language';\nimport { EditorSelection } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\n\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/\nvar snippets = [/*@__PURE__*/snippetCompletion(\"function ${name}(${params}) {\\n\\t${}\\n}\", {\n  label: \"function\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\\t${}\\n}\", {\n  label: \"for\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"for (let ${name} of ${collection}) {\\n\\t${}\\n}\", {\n  label: \"for\",\n  detail: \"of loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"do {\\n\\t${}\\n} while (${})\", {\n  label: \"do\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"while (${}) {\\n\\t${}\\n}\", {\n  label: \"while\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"try {\\n\\t${}\\n} catch (${error}) {\\n\\t${}\\n}\", {\n  label: \"try\",\n  detail: \"/ catch block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n}\", {\n  label: \"if\",\n  detail: \"block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n} else {\\n\\t${}\\n}\", {\n  label: \"if\",\n  detail: \"/ else block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"class ${name} {\\n\\tconstructor(${params}) {\\n\\t\\t${}\\n\\t}\\n}\", {\n  label: \"class\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"import {${names}} from \\\"${module}\\\"\\n${}\", {\n  label: \"import\",\n  detail: \"named\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"import ${name} from \\\"${module}\\\"\\n${}\", {\n  label: \"import\",\n  detail: \"default\",\n  type: \"keyword\"\n})];\nvar cache = /*@__PURE__*/new NodeWeakMap();\nvar ScopeNodes = /*@__PURE__*/new Set([\"Script\", \"Block\", \"FunctionExpression\", \"FunctionDeclaration\", \"ArrowFunction\", \"MethodDeclaration\", \"ForStatement\"]);\nfunction defID(type) {\n  return function (node, def) {\n    var id = node.node.getChild(\"VariableDefinition\");\n    if (id) def(id, type);\n    return true;\n  };\n}\nvar functionContext = [\"FunctionDeclaration\"];\nvar gatherCompletions = {\n  FunctionDeclaration: /*@__PURE__*/defID(\"function\"),\n  ClassDeclaration: /*@__PURE__*/defID(\"class\"),\n  ClassExpression: function ClassExpression() {\n    return true;\n  },\n  EnumDeclaration: /*@__PURE__*/defID(\"constant\"),\n  TypeAliasDeclaration: /*@__PURE__*/defID(\"type\"),\n  NamespaceDeclaration: /*@__PURE__*/defID(\"namespace\"),\n  VariableDefinition: function VariableDefinition(node, def) {\n    if (!node.matchContext(functionContext)) def(node, \"variable\");\n  },\n  TypeDefinition: function TypeDefinition(node, def) {\n    def(node, \"type\");\n  },\n  __proto__: null\n};\nfunction getScope(doc, node) {\n  var cached = cache.get(node);\n  if (cached) return cached;\n  var completions = [],\n    top = true;\n  function def(node, type) {\n    var name = doc.sliceString(node.from, node.to);\n    completions.push({\n      label: name,\n      type: type\n    });\n  }\n  node.cursor(IterMode.IncludeAnonymous).iterate(function (node) {\n    if (top) {\n      top = false;\n    } else if (node.name) {\n      var gather = gatherCompletions[node.name];\n      if (gather && gather(node, def) || ScopeNodes.has(node.name)) return false;\n    } else if (node.to - node.from > 8192) {\n      // Allow caching for bigger internal nodes\n      var _iterator = _createForOfIteratorHelper(getScope(doc, node.node)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var c = _step.value;\n          completions.push(c);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return false;\n    }\n  });\n  cache.set(node, completions);\n  return completions;\n}\nvar Identifier = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/;\nvar dontComplete = [\"TemplateString\", \"String\", \"RegExp\", \"LineComment\", \"BlockComment\", \"VariableDefinition\", \"TypeDefinition\", \"Label\", \"PropertyDefinition\", \"PropertyName\", \"PrivatePropertyDefinition\", \"PrivatePropertyName\", \".\", \"?.\"];\n/**\nCompletion source that looks up locally defined names in\nJavaScript code.\n*/\nfunction localCompletionSource(context) {\n  var inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n  if (dontComplete.indexOf(inner.name) > -1) return null;\n  var isWord = inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n  if (!isWord && !context.explicit) return null;\n  var options = [];\n  for (var pos = inner; pos; pos = pos.parent) {\n    if (ScopeNodes.has(pos.name)) options = options.concat(getScope(context.state.doc, pos));\n  }\n  return {\n    options: options,\n    from: isWord ? inner.from : context.pos,\n    validFor: Identifier\n  };\n}\nfunction pathFor(read, member, name) {\n  var _a;\n  var path = [];\n  for (;;) {\n    var obj = member.firstChild,\n      prop = void 0;\n    if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"VariableName\") {\n      path.push(read(obj));\n      return {\n        path: path.reverse(),\n        name: name\n      };\n    } else if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"MemberExpression\" && ((_a = prop = obj.lastChild) === null || _a === void 0 ? void 0 : _a.name) == \"PropertyName\") {\n      path.push(read(prop));\n      member = obj;\n    } else {\n      return null;\n    }\n  }\n}\n/**\nHelper function for defining JavaScript completion sources. It\nreturns the completable name and object path for a completion\ncontext, or null if no name/property completion should happen at\nthat position. For example, when completing after `a.b.c` it will\nreturn `{path: [\"a\", \"b\"], name: \"c\"}`. When completing after `x`\nit will return `{path: [], name: \"x\"}`. When not in a property or\nname, it will return null if `context.explicit` is false, and\n`{path: [], name: \"\"}` otherwise.\n*/\nfunction completionPath(context) {\n  var read = function read(node) {\n    return context.state.doc.sliceString(node.from, node.to);\n  };\n  var inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n  if (inner.name == \"PropertyName\") {\n    return pathFor(read, inner.parent, read(inner));\n  } else if ((inner.name == \".\" || inner.name == \"?.\") && inner.parent.name == \"MemberExpression\") {\n    return pathFor(read, inner.parent, \"\");\n  } else if (dontComplete.indexOf(inner.name) > -1) {\n    return null;\n  } else if (inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {\n    return {\n      path: [],\n      name: read(inner)\n    };\n  } else if (inner.name == \"MemberExpression\") {\n    return pathFor(read, inner, \"\");\n  } else {\n    return context.explicit ? {\n      path: [],\n      name: \"\"\n    } : null;\n  }\n}\nfunction enumeratePropertyCompletions(obj, top) {\n  var options = [],\n    seen = new Set();\n  for (var depth = 0;; depth++) {\n    var _iterator2 = _createForOfIteratorHelper((Object.getOwnPropertyNames || Object.keys)(obj)),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var name = _step2.value;\n        if (seen.has(name)) continue;\n        seen.add(name);\n        var value = void 0;\n        try {\n          value = obj[name];\n        } catch (_) {\n          continue;\n        }\n        options.push({\n          label: name,\n          type: typeof value == \"function\" ? /^[A-Z]/.test(name) ? \"class\" : top ? \"function\" : \"method\" : top ? \"variable\" : \"property\",\n          boost: -depth\n        });\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    var next = Object.getPrototypeOf(obj);\n    if (!next) return options;\n    obj = next;\n  }\n}\n/**\nDefines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that\ncompletes from the given scope object (for example `globalThis`).\nWill enter properties of the object when completing properties on\na directly-named path.\n*/\nfunction scopeCompletionSource(scope) {\n  var cache = new Map();\n  return function (context) {\n    var path = completionPath(context);\n    if (!path) return null;\n    var target = scope;\n    var _iterator3 = _createForOfIteratorHelper(path.path),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var step = _step3.value;\n        target = target[step];\n        if (!target) return null;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    var options = cache.get(target);\n    if (!options) cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));\n    return {\n      from: context.pos - path.name.length,\n      options: options,\n      validFor: Identifier\n    };\n  };\n}\n\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/\nvar javascriptLanguage = /*@__PURE__*/LRLanguage.define({\n  name: \"javascript\",\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      IfStatement: /*@__PURE__*/continuedIndent({\n        except: /^\\s*({|else\\b)/\n      }),\n      TryStatement: /*@__PURE__*/continuedIndent({\n        except: /^\\s*({|catch\\b|finally\\b)/\n      }),\n      LabeledStatement: flatIndent,\n      SwitchBody: function SwitchBody(context) {\n        var after = context.textAfter,\n          closed = /^\\s*\\}/.test(after),\n          isCase = /^\\s*(case|default)\\b/.test(after);\n        return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n      },\n      Block: /*@__PURE__*/delimitedIndent({\n        closing: \"}\"\n      }),\n      ArrowFunction: function ArrowFunction(cx) {\n        return cx.baseIndent + cx.unit;\n      },\n      \"TemplateString BlockComment\": function TemplateStringBlockComment() {\n        return null;\n      },\n      \"Statement Property\": /*@__PURE__*/continuedIndent({\n        except: /^{/\n      }),\n      JSXElement: function JSXElement(context) {\n        var closed = /^\\s*<\\//.test(context.textAfter);\n        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n      },\n      JSXEscape: function JSXEscape(context) {\n        var closed = /\\s*\\}/.test(context.textAfter);\n        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n      },\n      \"JSXOpenTag JSXSelfClosingTag\": function JSXOpenTagJSXSelfClosingTag(context) {\n        return context.column(context.node.from) + context.unit;\n      }\n    }), /*@__PURE__*/foldNodeProp.add({\n      \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": foldInside,\n      BlockComment: function BlockComment(tree) {\n        return {\n          from: tree.from + 2,\n          to: tree.to - 2\n        };\n      }\n    })]\n  }),\n  languageData: {\n    closeBrackets: {\n      brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"]\n    },\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    },\n    indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n    wordChars: \"$\"\n  }\n});\nvar jsxSublanguage = {\n  test: function test(node) {\n    return /^JSX/.test(node.name);\n  },\n  facet: /*@__PURE__*/defineLanguageFacet({\n    commentTokens: {\n      block: {\n        open: \"{/*\",\n        close: \"*/}\"\n      }\n    }\n  })\n};\n/**\nA language provider for TypeScript.\n*/\nvar typescriptLanguage = /*@__PURE__*/javascriptLanguage.configure({\n  dialect: \"ts\"\n}, \"typescript\");\n/**\nLanguage provider for JSX.\n*/\nvar jsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n  dialect: \"jsx\",\n  props: [/*@__PURE__*/sublanguageProp.add(function (n) {\n    return n.isTop ? [jsxSublanguage] : undefined;\n  })]\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/\nvar tsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n  dialect: \"jsx ts\",\n  props: [/*@__PURE__*/sublanguageProp.add(function (n) {\n    return n.isTop ? [jsxSublanguage] : undefined;\n  })]\n}, \"typescript\");\nvar keywords = /*@__PURE__*/\"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(function (kw) {\n  return {\n    label: kw,\n    type: \"keyword\"\n  };\n});\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\ncompletion.\n*/\nfunction javascript() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var lang = config.jsx ? config.typescript ? tsxLanguage : jsxLanguage : config.typescript ? typescriptLanguage : javascriptLanguage;\n  return new LanguageSupport(lang, [javascriptLanguage.data.of({\n    autocomplete: ifNotIn(dontComplete, completeFromList(snippets.concat(keywords)))\n  }), javascriptLanguage.data.of({\n    autocomplete: localCompletionSource\n  }), config.jsx ? autoCloseTags : []]);\n}\nfunction findOpenTag(node) {\n  for (;;) {\n    if (node.name == \"JSXOpenTag\" || node.name == \"JSXSelfClosingTag\" || node.name == \"JSXFragmentTag\") return node;\n    if (node.name == \"JSXEscape\" || !node.parent) return null;\n    node = node.parent;\n  }\n}\nfunction elementName(doc, tree) {\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : doc.length;\n  for (var ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {\n    if (ch.name == \"JSXIdentifier\" || ch.name == \"JSXBuiltin\" || ch.name == \"JSXNamespacedName\" || ch.name == \"JSXMemberExpression\") return doc.sliceString(ch.from, Math.min(ch.to, max));\n  }\n  return \"\";\n}\nfunction isEndTag(node) {\n  return node && (node.name == \"JSXEndTag\" || node.name == \"JSXSelfCloseEndTag\");\n}\nvar android = typeof navigator == \"object\" && /*@__PURE__*/ /Android\\b/.test(navigator.userAgent);\n/**\nExtension that will automatically insert JSX close tags when a `>` or\n`/` is typed.\n*/\nvar autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of(function (view, from, to, text) {\n  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly || from != to || text != \">\" && text != \"/\" || !javascriptLanguage.isActiveAt(view.state, from, -1)) return false;\n  var state = view.state;\n  var changes = state.changeByRange(function (range) {\n    var _a;\n    var head = range.head,\n      around = syntaxTree(state).resolveInner(head, -1),\n      name;\n    if (around.name == \"JSXStartTag\") around = around.parent;\n    if (around.name == \"JSXAttributeValue\" && around.to > head) ;else if (text == \">\" && around.name == \"JSXFragmentTag\") {\n      return {\n        range: EditorSelection.cursor(head + 1),\n        changes: {\n          from: head,\n          insert: \"></>\"\n        }\n      };\n    } else if (text == \"/\" && around.name == \"JSXFragmentTag\") {\n      var empty = around.parent,\n        base = empty === null || empty === void 0 ? void 0 : empty.parent;\n      if (empty.from == head - 1 && ((_a = base.lastChild) === null || _a === void 0 ? void 0 : _a.name) != \"JSXEndTag\" && (name = elementName(state.doc, base === null || base === void 0 ? void 0 : base.firstChild, head))) {\n        var insert = \"/\".concat(name, \">\");\n        return {\n          range: EditorSelection.cursor(head + insert.length),\n          changes: {\n            from: head,\n            insert: insert\n          }\n        };\n      }\n    } else if (text == \">\") {\n      var openTag = findOpenTag(around);\n      if (openTag && !isEndTag(openTag.lastChild) && state.sliceDoc(head, head + 2) != \"</\" && (name = elementName(state.doc, openTag, head))) return {\n        range: EditorSelection.cursor(head + 1),\n        changes: {\n          from: head,\n          insert: \"></\".concat(name, \">\")\n        }\n      };\n    }\n    return {\n      range: range\n    };\n  });\n  if (changes.changes.empty) return false;\n  view.dispatch(changes, {\n    userEvent: \"input.type\",\n    scrollIntoView: true\n  });\n  return true;\n});\n\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The\n[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)\npackage may help with that (see\n[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).\n*/\nfunction esLint(eslint, config) {\n  if (!config) {\n    config = {\n      parserOptions: {\n        ecmaVersion: 2019,\n        sourceType: \"module\"\n      },\n      env: {\n        browser: true,\n        node: true,\n        es6: true,\n        es2015: true,\n        es2017: true,\n        es2020: true\n      },\n      rules: {}\n    };\n    eslint.getRules().forEach(function (desc, name) {\n      if (desc.meta.docs.recommended) config.rules[name] = 2;\n    });\n  }\n  return function (view) {\n    var state = view.state,\n      found = [];\n    var _iterator4 = _createForOfIteratorHelper(javascriptLanguage.findRegions(state)),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _step4$value = _step4.value,\n          from = _step4$value.from,\n          to = _step4$value.to;\n        var fromLine = state.doc.lineAt(from),\n          offset = {\n            line: fromLine.number - 1,\n            col: from - fromLine.from,\n            pos: from\n          };\n        var _iterator5 = _createForOfIteratorHelper(eslint.verify(state.sliceDoc(from, to), config)),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var d = _step5.value;\n            found.push(translateDiagnostic(d, state.doc, offset));\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    return found;\n  };\n}\nfunction mapPos(line, col, doc, offset) {\n  return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\nfunction translateDiagnostic(input, doc, offset) {\n  var start = mapPos(input.line, input.column, doc, offset);\n  var result = {\n    from: start,\n    to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n    message: input.message,\n    source: input.ruleId ? \"eslint:\" + input.ruleId : \"eslint\",\n    severity: input.severity == 1 ? \"warning\" : \"error\"\n  };\n  if (input.fix) {\n    var _input$fix = input.fix,\n      range = _input$fix.range,\n      text = _input$fix.text,\n      from = range[0] + offset.pos - start,\n      to = range[1] + offset.pos - start;\n    result.actions = [{\n      name: \"fix\",\n      apply: function apply(view, start) {\n        view.dispatch({\n          changes: {\n            from: start + from,\n            to: start + to,\n            insert: text\n          },\n          scrollIntoView: true\n        });\n      }\n    }];\n  }\n  return result;\n}\nexport { autoCloseTags, completionPath, esLint, javascript, javascriptLanguage, jsxLanguage, localCompletionSource, scopeCompletionSource, snippets, tsxLanguage, typescriptLanguage };","map":{"version":3,"names":["parser","syntaxTree","LRLanguage","indentNodeProp","continuedIndent","flatIndent","delimitedIndent","foldNodeProp","foldInside","defineLanguageFacet","sublanguageProp","LanguageSupport","EditorSelection","EditorView","snippetCompletion","ifNotIn","completeFromList","NodeWeakMap","IterMode","snippets","label","detail","type","cache","ScopeNodes","Set","defID","node","def","id","getChild","functionContext","gatherCompletions","FunctionDeclaration","ClassDeclaration","ClassExpression","EnumDeclaration","TypeAliasDeclaration","NamespaceDeclaration","VariableDefinition","matchContext","TypeDefinition","__proto__","getScope","doc","cached","get","completions","top","name","sliceString","from","to","push","cursor","IncludeAnonymous","iterate","gather","has","_iterator","_createForOfIteratorHelper","_step","s","n","done","c","value","err","e","f","set","Identifier","dontComplete","localCompletionSource","context","inner","state","resolveInner","pos","indexOf","isWord","test","sliceDoc","explicit","options","parent","concat","validFor","pathFor","read","member","_a","path","obj","firstChild","prop","reverse","lastChild","completionPath","enumeratePropertyCompletions","seen","depth","_iterator2","Object","getOwnPropertyNames","keys","_step2","add","_","boost","next","getPrototypeOf","scopeCompletionSource","scope","Map","target","_iterator3","_step3","step","length","javascriptLanguage","define","configure","props","IfStatement","except","TryStatement","LabeledStatement","SwitchBody","after","textAfter","closed","isCase","baseIndent","unit","Block","closing","ArrowFunction","cx","TemplateStringBlockComment","JSXElement","lineIndent","JSXEscape","JSXOpenTagJSXSelfClosingTag","column","BlockComment","tree","languageData","closeBrackets","brackets","commentTokens","line","block","open","close","indentOnInput","wordChars","jsxSublanguage","facet","typescriptLanguage","dialect","jsxLanguage","isTop","undefined","tsxLanguage","keywords","split","map","kw","javascript","config","arguments","lang","jsx","typescript","data","of","autocomplete","autoCloseTags","findOpenTag","elementName","max","ch","nextSibling","Math","min","isEndTag","android","navigator","userAgent","inputHandler","view","text","composing","compositionStarted","readOnly","isActiveAt","changes","changeByRange","range","head","around","insert","empty","base","openTag","dispatch","userEvent","scrollIntoView","esLint","eslint","parserOptions","ecmaVersion","sourceType","env","browser","es6","es2015","es2017","es2020","rules","getRules","forEach","desc","meta","docs","recommended","found","_iterator4","findRegions","_step4","_step4$value","fromLine","lineAt","offset","number","col","_iterator5","verify","_step5","d","translateDiagnostic","mapPos","input","start","result","endLine","endColumn","message","source","ruleId","severity","fix","_input$fix","actions","apply"],"sources":["/Users/adityapethe/Developer/ui-chat/ui-chat/client/node_modules/@codemirror/lang-javascript/dist/index.js"],"sourcesContent":["import { parser } from '@lezer/javascript';\nimport { syntaxTree, LRLanguage, indentNodeProp, continuedIndent, flatIndent, delimitedIndent, foldNodeProp, foldInside, defineLanguageFacet, sublanguageProp, LanguageSupport } from '@codemirror/language';\nimport { EditorSelection } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\n\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/\nconst snippets = [\n    /*@__PURE__*/snippetCompletion(\"function ${name}(${params}) {\\n\\t${}\\n}\", {\n        label: \"function\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for (let ${name} of ${collection}) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"of loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"do {\\n\\t${}\\n} while (${})\", {\n        label: \"do\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"while (${}) {\\n\\t${}\\n}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"try {\\n\\t${}\\n} catch (${error}) {\\n\\t${}\\n}\", {\n        label: \"try\",\n        detail: \"/ catch block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n} else {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"class ${name} {\\n\\tconstructor(${params}) {\\n\\t\\t${}\\n\\t}\\n}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import {${names}} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"named\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import ${name} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"default\",\n        type: \"keyword\"\n    })\n];\n\nconst cache = /*@__PURE__*/new NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\n    \"Script\", \"Block\",\n    \"FunctionExpression\", \"FunctionDeclaration\", \"ArrowFunction\", \"MethodDeclaration\",\n    \"ForStatement\"\n]);\nfunction defID(type) {\n    return (node, def) => {\n        let id = node.node.getChild(\"VariableDefinition\");\n        if (id)\n            def(id, type);\n        return true;\n    };\n}\nconst functionContext = [\"FunctionDeclaration\"];\nconst gatherCompletions = {\n    FunctionDeclaration: /*@__PURE__*/defID(\"function\"),\n    ClassDeclaration: /*@__PURE__*/defID(\"class\"),\n    ClassExpression: () => true,\n    EnumDeclaration: /*@__PURE__*/defID(\"constant\"),\n    TypeAliasDeclaration: /*@__PURE__*/defID(\"type\"),\n    NamespaceDeclaration: /*@__PURE__*/defID(\"namespace\"),\n    VariableDefinition(node, def) { if (!node.matchContext(functionContext))\n        def(node, \"variable\"); },\n    TypeDefinition(node, def) { def(node, \"type\"); },\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached)\n        return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({ label: name, type });\n    }\n    node.cursor(IterMode.IncludeAnonymous).iterate(node => {\n        if (top) {\n            top = false;\n        }\n        else if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def) || ScopeNodes.has(node.name))\n                return false;\n        }\n        else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))\n                completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\n    \"TemplateString\", \"String\", \"RegExp\",\n    \"LineComment\", \"BlockComment\",\n    \"VariableDefinition\", \"TypeDefinition\", \"Label\",\n    \"PropertyDefinition\", \"PropertyName\",\n    \"PrivatePropertyDefinition\", \"PrivatePropertyName\",\n    \".\", \"?.\"\n];\n/**\nCompletion source that looks up locally defined names in\nJavaScript code.\n*/\nfunction localCompletionSource(context) {\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1)\n        return null;\n    let isWord = inner.name == \"VariableName\" ||\n        inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit)\n        return null;\n    let options = [];\n    for (let pos = inner; pos; pos = pos.parent) {\n        if (ScopeNodes.has(pos.name))\n            options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nfunction pathFor(read, member, name) {\n    var _a;\n    let path = [];\n    for (;;) {\n        let obj = member.firstChild, prop;\n        if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"VariableName\") {\n            path.push(read(obj));\n            return { path: path.reverse(), name };\n        }\n        else if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"MemberExpression\" && ((_a = (prop = obj.lastChild)) === null || _a === void 0 ? void 0 : _a.name) == \"PropertyName\") {\n            path.push(read(prop));\n            member = obj;\n        }\n        else {\n            return null;\n        }\n    }\n}\n/**\nHelper function for defining JavaScript completion sources. It\nreturns the completable name and object path for a completion\ncontext, or null if no name/property completion should happen at\nthat position. For example, when completing after `a.b.c` it will\nreturn `{path: [\"a\", \"b\"], name: \"c\"}`. When completing after `x`\nit will return `{path: [], name: \"x\"}`. When not in a property or\nname, it will return null if `context.explicit` is false, and\n`{path: [], name: \"\"}` otherwise.\n*/\nfunction completionPath(context) {\n    let read = (node) => context.state.doc.sliceString(node.from, node.to);\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (inner.name == \"PropertyName\") {\n        return pathFor(read, inner.parent, read(inner));\n    }\n    else if ((inner.name == \".\" || inner.name == \"?.\") && inner.parent.name == \"MemberExpression\") {\n        return pathFor(read, inner.parent, \"\");\n    }\n    else if (dontComplete.indexOf(inner.name) > -1) {\n        return null;\n    }\n    else if (inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {\n        return { path: [], name: read(inner) };\n    }\n    else if (inner.name == \"MemberExpression\") {\n        return pathFor(read, inner, \"\");\n    }\n    else {\n        return context.explicit ? { path: [], name: \"\" } : null;\n    }\n}\nfunction enumeratePropertyCompletions(obj, top) {\n    let options = [], seen = new Set;\n    for (let depth = 0;; depth++) {\n        for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)) {\n            if (seen.has(name))\n                continue;\n            seen.add(name);\n            let value;\n            try {\n                value = obj[name];\n            }\n            catch (_) {\n                continue;\n            }\n            options.push({\n                label: name,\n                type: typeof value == \"function\" ? (/^[A-Z]/.test(name) ? \"class\" : top ? \"function\" : \"method\")\n                    : top ? \"variable\" : \"property\",\n                boost: -depth\n            });\n        }\n        let next = Object.getPrototypeOf(obj);\n        if (!next)\n            return options;\n        obj = next;\n    }\n}\n/**\nDefines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that\ncompletes from the given scope object (for example `globalThis`).\nWill enter properties of the object when completing properties on\na directly-named path.\n*/\nfunction scopeCompletionSource(scope) {\n    let cache = new Map;\n    return (context) => {\n        let path = completionPath(context);\n        if (!path)\n            return null;\n        let target = scope;\n        for (let step of path.path) {\n            target = target[step];\n            if (!target)\n                return null;\n        }\n        let options = cache.get(target);\n        if (!options)\n            cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));\n        return {\n            from: context.pos - path.name.length,\n            options,\n            validFor: Identifier\n        };\n    };\n}\n\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/\nconst javascriptLanguage = /*@__PURE__*/LRLanguage.define({\n    name: \"javascript\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                IfStatement: /*@__PURE__*/continuedIndent({ except: /^\\s*({|else\\b)/ }),\n                TryStatement: /*@__PURE__*/continuedIndent({ except: /^\\s*({|catch\\b|finally\\b)/ }),\n                LabeledStatement: flatIndent,\n                SwitchBody: context => {\n                    let after = context.textAfter, closed = /^\\s*\\}/.test(after), isCase = /^\\s*(case|default)\\b/.test(after);\n                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n                },\n                Block: /*@__PURE__*/delimitedIndent({ closing: \"}\" }),\n                ArrowFunction: cx => cx.baseIndent + cx.unit,\n                \"TemplateString BlockComment\": () => null,\n                \"Statement Property\": /*@__PURE__*/continuedIndent({ except: /^{/ }),\n                JSXElement(context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                JSXEscape(context) {\n                    let closed = /\\s*\\}/.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                \"JSXOpenTag JSXSelfClosingTag\"(context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": foldInside,\n                BlockComment(tree) { return { from: tree.from + 2, to: tree.to - 2 }; }\n            })\n        ]\n    }),\n    languageData: {\n        closeBrackets: { brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"] },\n        commentTokens: { line: \"//\", block: { open: \"/*\", close: \"*/\" } },\n        indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n        wordChars: \"$\"\n    }\n});\nconst jsxSublanguage = {\n    test: node => /^JSX/.test(node.name),\n    facet: /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: \"{/*\", close: \"*/}\" } } })\n};\n/**\nA language provider for TypeScript.\n*/\nconst typescriptLanguage = /*@__PURE__*/javascriptLanguage.configure({ dialect: \"ts\" }, \"typescript\");\n/**\nLanguage provider for JSX.\n*/\nconst jsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx\",\n    props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/\nconst tsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx ts\",\n    props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n}, \"typescript\");\nconst keywords = /*@__PURE__*/\"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(kw => ({ label: kw, type: \"keyword\" }));\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\ncompletion.\n*/\nfunction javascript(config = {}) {\n    let lang = config.jsx ? (config.typescript ? tsxLanguage : jsxLanguage)\n        : config.typescript ? typescriptLanguage : javascriptLanguage;\n    return new LanguageSupport(lang, [\n        javascriptLanguage.data.of({\n            autocomplete: ifNotIn(dontComplete, completeFromList(snippets.concat(keywords)))\n        }),\n        javascriptLanguage.data.of({\n            autocomplete: localCompletionSource\n        }),\n        config.jsx ? autoCloseTags : [],\n    ]);\n}\nfunction findOpenTag(node) {\n    for (;;) {\n        if (node.name == \"JSXOpenTag\" || node.name == \"JSXSelfClosingTag\" || node.name == \"JSXFragmentTag\")\n            return node;\n        if (node.name == \"JSXEscape\" || !node.parent)\n            return null;\n        node = node.parent;\n    }\n}\nfunction elementName(doc, tree, max = doc.length) {\n    for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {\n        if (ch.name == \"JSXIdentifier\" || ch.name == \"JSXBuiltin\" || ch.name == \"JSXNamespacedName\" ||\n            ch.name == \"JSXMemberExpression\")\n            return doc.sliceString(ch.from, Math.min(ch.to, max));\n    }\n    return \"\";\n}\nfunction isEndTag(node) {\n    return node && (node.name == \"JSXEndTag\" || node.name == \"JSXSelfCloseEndTag\");\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*//Android\\b/.test(navigator.userAgent);\n/**\nExtension that will automatically insert JSX close tags when a `>` or\n`/` is typed.\n*/\nconst autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, text) => {\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly ||\n        from != to || (text != \">\" && text != \"/\") ||\n        !javascriptLanguage.isActiveAt(view.state, from, -1))\n        return false;\n    let { state } = view;\n    let changes = state.changeByRange(range => {\n        var _a;\n        let { head } = range, around = syntaxTree(state).resolveInner(head, -1), name;\n        if (around.name == \"JSXStartTag\")\n            around = around.parent;\n        if (around.name == \"JSXAttributeValue\" && around.to > head) ;\n        else if (text == \">\" && around.name == \"JSXFragmentTag\") {\n            return { range: EditorSelection.cursor(head + 1), changes: { from: head, insert: `></>` } };\n        }\n        else if (text == \"/\" && around.name == \"JSXFragmentTag\") {\n            let empty = around.parent, base = empty === null || empty === void 0 ? void 0 : empty.parent;\n            if (empty.from == head - 1 && ((_a = base.lastChild) === null || _a === void 0 ? void 0 : _a.name) != \"JSXEndTag\" &&\n                (name = elementName(state.doc, base === null || base === void 0 ? void 0 : base.firstChild, head))) {\n                let insert = `/${name}>`;\n                return { range: EditorSelection.cursor(head + insert.length), changes: { from: head, insert } };\n            }\n        }\n        else if (text == \">\") {\n            let openTag = findOpenTag(around);\n            if (openTag && !isEndTag(openTag.lastChild) &&\n                state.sliceDoc(head, head + 2) != \"</\" &&\n                (name = elementName(state.doc, openTag, head)))\n                return { range: EditorSelection.cursor(head + 1), changes: { from: head, insert: `></${name}>` } };\n        }\n        return { range };\n    });\n    if (changes.changes.empty)\n        return false;\n    view.dispatch(changes, { userEvent: \"input.type\", scrollIntoView: true });\n    return true;\n});\n\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The\n[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)\npackage may help with that (see\n[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).\n*/\nfunction esLint(eslint, config) {\n    if (!config) {\n        config = {\n            parserOptions: { ecmaVersion: 2019, sourceType: \"module\" },\n            env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },\n            rules: {}\n        };\n        eslint.getRules().forEach((desc, name) => {\n            if (desc.meta.docs.recommended)\n                config.rules[name] = 2;\n        });\n    }\n    return (view) => {\n        let { state } = view, found = [];\n        for (let { from, to } of javascriptLanguage.findRegions(state)) {\n            let fromLine = state.doc.lineAt(from), offset = { line: fromLine.number - 1, col: from - fromLine.from, pos: from };\n            for (let d of eslint.verify(state.sliceDoc(from, to), config))\n                found.push(translateDiagnostic(d, state.doc, offset));\n        }\n        return found;\n    };\n}\nfunction mapPos(line, col, doc, offset) {\n    return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\nfunction translateDiagnostic(input, doc, offset) {\n    let start = mapPos(input.line, input.column, doc, offset);\n    let result = {\n        from: start,\n        to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n        message: input.message,\n        source: input.ruleId ? \"eslint:\" + input.ruleId : \"eslint\",\n        severity: input.severity == 1 ? \"warning\" : \"error\",\n    };\n    if (input.fix) {\n        let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;\n        result.actions = [{\n                name: \"fix\",\n                apply(view, start) {\n                    view.dispatch({ changes: { from: start + from, to: start + to, insert: text }, scrollIntoView: true });\n                }\n            }];\n    }\n    return result;\n}\n\nexport { autoCloseTags, completionPath, esLint, javascript, javascriptLanguage, jsxLanguage, localCompletionSource, scopeCompletionSource, snippets, tsxLanguage, typescriptLanguage };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}