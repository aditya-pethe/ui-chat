{"ast":null,"code":"import _slicedToArray from \"/Users/adityapethe/Developer/ui-chat/ui-chat/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/adityapethe/Developer/ui-chat/ui-chat/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _createClass from \"/Users/adityapethe/Developer/ui-chat/ui-chat/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/adityapethe/Developer/ui-chat/ui-chat/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\n// FIXME profile adding a per-Tree TreeNode cache, validating it by\n// parent pointer\n/// The default maximum length of a `TreeBuffer` node.\nvar DefaultBufferLength = 1024;\nvar nextPropID = 0;\nvar Range = /*#__PURE__*/_createClass(function Range(from, to) {\n  _classCallCheck(this, Range);\n  this.from = from;\n  this.to = to;\n}); /// Each [node type](#common.NodeType) or [individual tree](#common.Tree)\n/// can have metadata associated with it in props. Instances of this\n/// class represent prop names.\nvar NodeProp = /*#__PURE__*/function () {\n  /// Create a new node prop type.\n  function NodeProp() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, NodeProp);\n    this.id = nextPropID++;\n    this.perNode = !!config.perNode;\n    this.deserialize = config.deserialize || function () {\n      throw new Error(\"This node type doesn't define a deserialize function\");\n    };\n  }\n  /// This is meant to be used with\n  /// [`NodeSet.extend`](#common.NodeSet.extend) or\n  /// [`LRParser.configure`](#lr.ParserConfig.props) to compute\n  /// prop values for each node type in the set. Takes a [match\n  /// object](#common.NodeType^match) or function that returns undefined\n  /// if the node type doesn't get this prop, and the prop's value if\n  /// it does.\n  _createClass(NodeProp, [{\n    key: \"add\",\n    value: function add(match) {\n      var _this = this;\n      if (this.perNode) throw new RangeError(\"Can't add per-node props to node types\");\n      if (typeof match != \"function\") match = NodeType.match(match);\n      return function (type) {\n        var result = match(type);\n        return result === undefined ? null : [_this, result];\n      };\n    }\n  }]);\n  return NodeProp;\n}(); /// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\nNodeProp.closedBy = new NodeProp({\n  deserialize: function deserialize(str) {\n    return str.split(\" \");\n  }\n});\n/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\nNodeProp.openedBy = new NodeProp({\n  deserialize: function deserialize(str) {\n    return str.split(\" \");\n  }\n});\n/// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\nNodeProp.group = new NodeProp({\n  deserialize: function deserialize(str) {\n    return str.split(\" \");\n  }\n});\n/// The hash of the [context](#lr.ContextTracker.constructor)\n/// that the node was parsed in, if any. Used to limit reuse of\n/// contextual nodes.\nNodeProp.contextHash = new NodeProp({\n  perNode: true\n});\n/// The distance beyond the end of the node that the tokenizer\n/// looked ahead for any of the tokens inside the node. (The LR\n/// parser only stores this when it is larger than 25, for\n/// efficiency reasons.)\nNodeProp.lookAhead = new NodeProp({\n  perNode: true\n});\n/// This per-node prop is used to replace a given node, or part of a\n/// node, with another tree. This is useful to include trees from\n/// different languages in mixed-language parsers.\nNodeProp.mounted = new NodeProp({\n  perNode: true\n});\n/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on\n/// a tree node to indicate that parts of its content are\n/// represented by another tree.\nvar MountedTree = /*#__PURE__*/_createClass(function MountedTree(\n/// The inner tree.\ntree,\n/// If this is null, this tree replaces the entire node (it will\n/// be included in the regular iteration instead of its host\n/// node). If not, only the given ranges are considered to be\n/// covered by this tree. This is used for trees that are mixed in\n/// a way that isn't strictly hierarchical. Such mounted trees are\n/// only entered by [`resolveInner`](#common.Tree.resolveInner)\n/// and [`enter`](#common.SyntaxNode.enter).\noverlay,\n/// The parser used to create this subtree.\nparser) {\n  _classCallCheck(this, MountedTree);\n  this.tree = tree;\n  this.overlay = overlay;\n  this.parser = parser;\n});\nvar noProps = Object.create(null);\n/// Each node in a syntax tree has a node type associated with it.\nvar NodeType = /*#__PURE__*/function () {\n  /// @internal\n  function NodeType(\n  /// The name of the node type. Not necessarily unique, but if the\n  /// grammar was written properly, different node types with the\n  /// same name within a node set should play the same semantic\n  /// role.\n  name,\n  /// @internal\n  props,\n  /// The id of this node in its set. Corresponds to the term ids\n  /// used in the parser.\n  id) {\n    var flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    _classCallCheck(this, NodeType);\n    this.name = name;\n    this.props = props;\n    this.id = id;\n    this.flags = flags;\n  }\n  /// Define a node type.\n  _createClass(NodeType, [{\n    key: \"prop\",\n    value:\n    /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    function prop(_prop) {\n      return this.props[_prop.id];\n    }\n    /// True when this is the top node of a grammar.\n  }, {\n    key: \"isTop\",\n    get: function get() {\n      return (this.flags & 1 /* NodeFlag.Top */) > 0;\n    }\n    /// True when this node is produced by a skip rule.\n  }, {\n    key: \"isSkipped\",\n    get: function get() {\n      return (this.flags & 2 /* NodeFlag.Skipped */) > 0;\n    }\n    /// Indicates whether this is an error node.\n  }, {\n    key: \"isError\",\n    get: function get() {\n      return (this.flags & 4 /* NodeFlag.Error */) > 0;\n    }\n    /// When true, this node type doesn't correspond to a user-declared\n    /// named node, for example because it is used to cache repetition.\n  }, {\n    key: \"isAnonymous\",\n    get: function get() {\n      return (this.flags & 8 /* NodeFlag.Anonymous */) > 0;\n    }\n    /// Returns true when this node's name or one of its\n    /// [groups](#common.NodeProp^group) matches the given string.\n  }, {\n    key: \"is\",\n    value: function is(name) {\n      if (typeof name == 'string') {\n        if (this.name == name) return true;\n        var group = this.prop(NodeProp.group);\n        return group ? group.indexOf(name) > -1 : false;\n      }\n      return this.id == name;\n    }\n    /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node or\n    /// [group](#common.NodeProp^group) names. Often useful with\n    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    /// names, separated by spaces, in a single property name to map\n    /// multiple node names to a single value.\n  }], [{\n    key: \"define\",\n    value: function define(spec) {\n      var props = spec.props && spec.props.length ? Object.create(null) : noProps;\n      var flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) | (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);\n      var type = new NodeType(spec.name || \"\", props, spec.id, flags);\n      if (spec.props) {\n        var _iterator = _createForOfIteratorHelper(spec.props),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var src = _step.value;\n            if (!Array.isArray(src)) src = src(type);\n            if (src) {\n              if (src[0].perNode) throw new RangeError(\"Can't store a per-node prop on a node type\");\n              props[src[0].id] = src[1];\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      return type;\n    }\n  }, {\n    key: \"match\",\n    value: function match(map) {\n      var direct = Object.create(null);\n      for (var prop in map) {\n        var _iterator2 = _createForOfIteratorHelper(prop.split(\" \")),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var name = _step2.value;\n            direct[name] = map[prop];\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      return function (node) {\n        for (var groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n          var found = direct[i < 0 ? node.name : groups[i]];\n          if (found) return found;\n        }\n      };\n    }\n  }]);\n  return NodeType;\n}(); /// An empty dummy node type to use when no actual type is available.\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a numeric array. Each parser\n/// [has](#lr.LRParser.nodeSet) a node set, and [tree\n/// buffers](#common.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536) node\n/// types in it, so that the ids fit into 16-bit typed array slots.\nvar NodeSet = /*#__PURE__*/function () {\n  /// Create a set with the given types. The `id` property of each\n  /// type should correspond to its position within the array.\n  function NodeSet(\n  /// The node types in this set, by id.\n  types) {\n    _classCallCheck(this, NodeSet);\n    this.types = types;\n    for (var i = 0; i < types.length; i++) if (types[i].id != i) throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n  }\n  /// Create a copy of this set with some node properties added. The\n  /// arguments to this method can be created with\n  /// [`NodeProp.add`](#common.NodeProp.add).\n  _createClass(NodeSet, [{\n    key: \"extend\",\n    value: function extend() {\n      var newTypes = [];\n      for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n        props[_key] = arguments[_key];\n      }\n      var _iterator3 = _createForOfIteratorHelper(this.types),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var type = _step3.value;\n          var newProps = null;\n          var _iterator4 = _createForOfIteratorHelper(props),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var source = _step4.value;\n              var add = source(type);\n              if (add) {\n                if (!newProps) newProps = Object.assign({}, type.props);\n                newProps[add[0].id] = add[1];\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return new NodeSet(newTypes);\n    }\n  }]);\n  return NodeSet;\n}();\nvar CachedNode = new WeakMap(),\n  CachedInnerNode = new WeakMap();\n/// Options that control iteration. Can be combined with the `|`\n/// operator to enable multiple ones.\nvar IterMode;\n(function (IterMode) {\n  /// When enabled, iteration will only visit [`Tree`](#common.Tree)\n  /// objects, not nodes packed into\n  /// [`TreeBuffer`](#common.TreeBuffer)s.\n  IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n  /// Enable this to make iteration include anonymous nodes (such as\n  /// the nodes that wrap repeated grammar constructs into a balanced\n  /// tree).\n  IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n  /// By default, regular [mounted](#common.NodeProp^mounted) nodes\n  /// replace their base node in iteration. Enable this to ignore them\n  /// instead.\n  IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n  /// This option only applies in\n  /// [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n  /// library to not enter mounted overlays if one covers the given\n  /// position.\n  IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the [`TreeCursor`](#common.TreeCursor) or\n/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\n/// a view on some part of this data structure, and can be used to\n/// move around to adjacent nodes.\nvar Tree = /*#__PURE__*/function () {\n  /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n  function Tree(\n  /// The type of the top node.\n  type,\n  /// This node's child nodes.\n  children,\n  /// The positions (offsets relative to the start of this tree) of\n  /// the children.\n  positions,\n  /// The total length of this tree\n  length,\n  /// Per-node [node props](#common.NodeProp) to associate with this node.\n  props) {\n    _classCallCheck(this, Tree);\n    this.type = type;\n    this.children = children;\n    this.positions = positions;\n    this.length = length;\n    /// @internal\n    this.props = null;\n    if (props && props.length) {\n      this.props = Object.create(null);\n      var _iterator5 = _createForOfIteratorHelper(props),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n            prop = _step5$value[0],\n            value = _step5$value[1];\n          this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }\n  /// @internal\n  _createClass(Tree, [{\n    key: \"toString\",\n    value: function toString() {\n      var mounted = this.prop(NodeProp.mounted);\n      if (mounted && !mounted.overlay) return mounted.tree.toString();\n      var children = \"\";\n      var _iterator6 = _createForOfIteratorHelper(this.children),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var ch = _step6.value;\n          var str = ch.toString();\n          if (str) {\n            if (children) children += \",\";\n            children += str;\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      return !this.type.name ? children : (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /// Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    /// the tree. Mode can be used to [control](#common.IterMode) which\n    /// nodes the cursor visits.\n  }, {\n    key: \"cursor\",\n    value: function cursor() {\n      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return new TreeCursor(this.topNode, mode);\n    }\n    /// Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    /// at the given position and side (see\n    /// [`moveTo`](#common.TreeCursor.moveTo).\n  }, {\n    key: \"cursorAt\",\n    value: function cursorAt(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var scope = CachedNode.get(this) || this.topNode;\n      var cursor = new TreeCursor(scope);\n      cursor.moveTo(pos, side);\n      CachedNode.set(this, cursor._tree);\n      return cursor;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) object for the top of the\n    /// tree.\n  }, {\n    key: \"topNode\",\n    get: function get() {\n      return new TreeNode(this, 0, 0, null);\n    }\n    /// Get the [syntax node](#common.SyntaxNode) at the given position.\n    /// If `side` is -1, this will move into nodes that end at the\n    /// position. If 1, it'll move into nodes that start at the\n    /// position. With 0, it'll only enter nodes that cover the position\n    /// from both sides.\n    ///\n    /// Note that this will not enter\n    /// [overlays](#common.MountedTree.overlay), and you often want\n    /// [`resolveInner`](#common.Tree.resolveInner) instead.\n  }, {\n    key: \"resolve\",\n    value: function resolve(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n      CachedNode.set(this, node);\n      return node;\n    }\n    /// Like [`resolve`](#common.Tree.resolve), but will enter\n    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    /// pointing into the innermost overlaid tree at the given position\n    /// (with parent links going through all parent structure, including\n    /// the host trees).\n  }, {\n    key: \"resolveInner\",\n    value: function resolveInner(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n      CachedInnerNode.set(this, node);\n      return node;\n    }\n    /// Iterate over the tree and its children, calling `enter` for any\n    /// node that touches the `from`/`to` region (if given) before\n    /// running over such a node's children, and `leave` (if given) when\n    /// leaving the node. When `enter` returns `false`, that node will\n    /// not have its children iterated over (or `leave` called).\n  }, {\n    key: \"iterate\",\n    value: function iterate(spec) {\n      var enter = spec.enter,\n        leave = spec.leave,\n        _spec$from = spec.from,\n        from = _spec$from === void 0 ? 0 : _spec$from,\n        _spec$to = spec.to,\n        to = _spec$to === void 0 ? this.length : _spec$to;\n      for (var c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous);;) {\n        var entered = false;\n        if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {\n          if (c.firstChild()) continue;\n          entered = true;\n        }\n        for (;;) {\n          if (entered && leave && !c.type.isAnonymous) leave(c);\n          if (c.nextSibling()) break;\n          if (!c.parent()) return;\n          entered = true;\n        }\n      }\n    }\n    /// Get the value of the given [node prop](#common.NodeProp) for this\n    /// node. Works with both per-node and per-type props.\n  }, {\n    key: \"prop\",\n    value: function prop(_prop2) {\n      return !_prop2.perNode ? this.type.prop(_prop2) : this.props ? this.props[_prop2.id] : undefined;\n    }\n    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    /// format that can be passed to the [`Tree`](#common.Tree)\n    /// constructor.\n  }, {\n    key: \"propValues\",\n    get: function get() {\n      var result = [];\n      if (this.props) for (var id in this.props) result.push([+id, this.props[id]]);\n      return result;\n    }\n    /// Balance the direct children of this tree, producing a copy of\n    /// which may have children grouped into subtrees with type\n    /// [`NodeType.none`](#common.NodeType^none).\n  }, {\n    key: \"balance\",\n    value: function balance() {\n      var _this2 = this;\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.children.length <= 8 /* Balance.BranchFactor */ ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, function (children, positions, length) {\n        return new Tree(_this2.type, children, positions, length, _this2.propValues);\n      }, config.makeTree || function (children, positions, length) {\n        return new Tree(NodeType.none, children, positions, length);\n      });\n    }\n    /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n  }], [{\n    key: \"build\",\n    value: function build(data) {\n      return buildTree(data);\n    }\n  }]);\n  return Tree;\n}(); /// The empty tree\nTree.empty = new Tree(NodeType.none, [], [], 0);\nvar FlatBufferCursor = /*#__PURE__*/function () {\n  function FlatBufferCursor(buffer, index) {\n    _classCallCheck(this, FlatBufferCursor);\n    this.buffer = buffer;\n    this.index = index;\n  }\n  _createClass(FlatBufferCursor, [{\n    key: \"id\",\n    get: function get() {\n      return this.buffer[this.index - 4];\n    }\n  }, {\n    key: \"start\",\n    get: function get() {\n      return this.buffer[this.index - 3];\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.buffer[this.index - 2];\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.buffer[this.index - 1];\n    }\n  }, {\n    key: \"pos\",\n    get: function get() {\n      return this.index;\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      this.index -= 4;\n    }\n  }, {\n    key: \"fork\",\n    value: function fork() {\n      return new FlatBufferCursor(this.buffer, this.index);\n    }\n  }]);\n  return FlatBufferCursor;\n}(); /// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it).\nvar TreeBuffer = /*#__PURE__*/function () {\n  /// Create a tree buffer.\n  function TreeBuffer(\n  /// The buffer's content.\n  buffer,\n  /// The total length of the group of nodes in the buffer.\n  length,\n  /// The node set used in this buffer.\n  set) {\n    _classCallCheck(this, TreeBuffer);\n    this.buffer = buffer;\n    this.length = length;\n    this.set = set;\n  }\n  /// @internal\n  _createClass(TreeBuffer, [{\n    key: \"type\",\n    get: function get() {\n      return NodeType.none;\n    }\n    /// @internal\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var result = [];\n      for (var index = 0; index < this.buffer.length;) {\n        result.push(this.childString(index));\n        index = this.buffer[index + 3];\n      }\n      return result.join(\",\");\n    }\n    /// @internal\n  }, {\n    key: \"childString\",\n    value: function childString(index) {\n      var id = this.buffer[index],\n        endIndex = this.buffer[index + 3];\n      var type = this.set.types[id],\n        result = type.name;\n      if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result);\n      index += 4;\n      if (endIndex == index) return result;\n      var children = [];\n      while (index < endIndex) {\n        children.push(this.childString(index));\n        index = this.buffer[index + 3];\n      }\n      return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /// @internal\n  }, {\n    key: \"findChild\",\n    value: function findChild(startIndex, endIndex, dir, pos, side) {\n      var buffer = this.buffer,\n        pick = -1;\n      for (var i = startIndex; i != endIndex; i = buffer[i + 3]) {\n        if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n          pick = i;\n          if (dir > 0) break;\n        }\n      }\n      return pick;\n    }\n    /// @internal\n  }, {\n    key: \"slice\",\n    value: function slice(startI, endI, from) {\n      var b = this.buffer;\n      var copy = new Uint16Array(endI - startI),\n        len = 0;\n      for (var i = startI, j = 0; i < endI;) {\n        copy[j++] = b[i++];\n        copy[j++] = b[i++] - from;\n        var to = copy[j++] = b[i++] - from;\n        copy[j++] = b[i++] - startI;\n        len = Math.max(len, to);\n      }\n      return new TreeBuffer(copy, len, this.set);\n    }\n  }]);\n  return TreeBuffer;\n}();\nfunction checkSide(side, pos, from, to) {\n  switch (side) {\n    case -2 /* Side.Before */:\n      return from < pos;\n    case -1 /* Side.AtOrBefore */:\n      return to >= pos && from < pos;\n    case 0 /* Side.Around */:\n      return from < pos && to > pos;\n    case 1 /* Side.AtOrAfter */:\n      return from <= pos && to > pos;\n    case 2 /* Side.After */:\n      return to > pos;\n    case 4 /* Side.DontCare */:\n      return true;\n  }\n}\nfunction _enterUnfinishedNodesBefore(node, pos) {\n  var scan = node.childBefore(pos);\n  while (scan) {\n    var last = scan.lastChild;\n    if (!last || last.to != scan.to) break;\n    if (last.type.isError && last.from == last.to) {\n      node = scan;\n      scan = last.prevSibling;\n    } else {\n      scan = last;\n    }\n  }\n  return node;\n}\nfunction resolveNode(node, pos, side, overlays) {\n  var _a;\n  // Move up to a node that actually holds the position, if possible\n  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {\n    var parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n    if (!parent) return node;\n    node = parent;\n  }\n  var mode = overlays ? 0 : IterMode.IgnoreOverlays;\n  // Must go up out of overlays when those do not overlap with pos\n  if (overlays) for (var scan = node, _parent2 = scan.parent; _parent2; scan = _parent2, _parent2 = scan.parent) {\n    if (scan instanceof TreeNode && scan.index < 0 && ((_a = _parent2.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from) node = _parent2;\n  }\n  for (;;) {\n    var inner = node.enter(pos, side, mode);\n    if (!inner) return node;\n    node = inner;\n  }\n}\nvar TreeNode = /*#__PURE__*/function () {\n  function TreeNode(_tree, from,\n  // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n  index, _parent) {\n    _classCallCheck(this, TreeNode);\n    this._tree = _tree;\n    this.from = from;\n    this.index = index;\n    this._parent = _parent;\n  }\n  _createClass(TreeNode, [{\n    key: \"type\",\n    get: function get() {\n      return this._tree.type;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this._tree.type.name;\n    }\n  }, {\n    key: \"to\",\n    get: function get() {\n      return this.from + this._tree.length;\n    }\n  }, {\n    key: \"nextChild\",\n    value: function nextChild(i, dir, pos, side) {\n      var mode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      for (var parent = this;;) {\n        for (var _parent$_tree = parent._tree, children = _parent$_tree.children, positions = _parent$_tree.positions, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n          var next = children[i],\n            start = positions[i] + parent.from;\n          if (!checkSide(side, pos, start, start + next.length)) continue;\n          if (next instanceof TreeBuffer) {\n            if (mode & IterMode.ExcludeBuffers) continue;\n            var index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n            if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n          } else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {\n            var mounted = void 0;\n            if (!(mode & IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent);\n            var inner = new TreeNode(next, start, i, parent);\n            return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n          }\n        }\n        if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous) return null;\n        if (parent.index >= 0) i = parent.index + dir;else i = dir < 0 ? -1 : parent._parent._tree.children.length;\n        parent = parent._parent;\n        if (!parent) return null;\n      }\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.nextChild(0, 1, 0, 4 /* Side.DontCare */);\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */);\n    }\n  }, {\n    key: \"childAfter\",\n    value: function childAfter(pos) {\n      return this.nextChild(0, 1, pos, 2 /* Side.After */);\n    }\n  }, {\n    key: \"childBefore\",\n    value: function childBefore(pos) {\n      return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */);\n    }\n  }, {\n    key: \"enter\",\n    value: function enter(pos, side) {\n      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var mounted;\n      if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {\n        var rPos = pos - this.from;\n        var _iterator7 = _createForOfIteratorHelper(mounted.overlay),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var _step7$value = _step7.value,\n              from = _step7$value.from,\n              to = _step7$value.to;\n            if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n      return this.nextChild(0, 1, pos, side, mode);\n    }\n  }, {\n    key: \"nextSignificantParent\",\n    value: function nextSignificantParent() {\n      var val = this;\n      while (val.type.isAnonymous && val._parent) val = val._parent;\n      return val;\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;\n    }\n  }, {\n    key: \"prevSibling\",\n    get: function get() {\n      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;\n    }\n  }, {\n    key: \"cursor\",\n    value: function cursor() {\n      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return new TreeCursor(this, mode);\n    }\n  }, {\n    key: \"tree\",\n    get: function get() {\n      return this._tree;\n    }\n  }, {\n    key: \"toTree\",\n    value: function toTree() {\n      return this._tree;\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return resolveNode(this, pos, side, false);\n    }\n  }, {\n    key: \"resolveInner\",\n    value: function resolveInner(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return resolveNode(this, pos, side, true);\n    }\n  }, {\n    key: \"enterUnfinishedNodesBefore\",\n    value: function enterUnfinishedNodesBefore(pos) {\n      return _enterUnfinishedNodesBefore(this, pos);\n    }\n  }, {\n    key: \"getChild\",\n    value: function getChild(type) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var r = _getChildren(this, type, before, after);\n      return r.length ? r[0] : null;\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(type) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      return _getChildren(this, type, before, after);\n    }\n    /// @internal\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._tree.toString();\n    }\n  }, {\n    key: \"node\",\n    get: function get() {\n      return this;\n    }\n  }, {\n    key: \"matchContext\",\n    value: function matchContext(context) {\n      return matchNodeContext(this, context);\n    }\n  }]);\n  return TreeNode;\n}();\nfunction _getChildren(node, type, before, after) {\n  var cur = node.cursor(),\n    result = [];\n  if (!cur.firstChild()) return result;\n  if (before != null) while (!cur.type.is(before)) if (!cur.nextSibling()) return result;\n  for (;;) {\n    if (after != null && cur.type.is(after)) return result;\n    if (cur.type.is(type)) result.push(cur.node);\n    if (!cur.nextSibling()) return after == null ? result : [];\n  }\n}\nfunction matchNodeContext(node, context) {\n  var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : context.length - 1;\n  for (var p = node.parent; i >= 0; p = p.parent) {\n    if (!p) return false;\n    if (!p.type.isAnonymous) {\n      if (context[i] && context[i] != p.name) return false;\n      i--;\n    }\n  }\n  return true;\n}\nvar BufferContext = /*#__PURE__*/_createClass(function BufferContext(parent, buffer, index, start) {\n  _classCallCheck(this, BufferContext);\n  this.parent = parent;\n  this.buffer = buffer;\n  this.index = index;\n  this.start = start;\n});\nvar BufferNode = /*#__PURE__*/function () {\n  function BufferNode(context, _parent, index) {\n    _classCallCheck(this, BufferNode);\n    this.context = context;\n    this._parent = _parent;\n    this.index = index;\n    this.type = context.buffer.set.types[context.buffer.buffer[index]];\n  }\n  _createClass(BufferNode, [{\n    key: \"name\",\n    get: function get() {\n      return this.type.name;\n    }\n  }, {\n    key: \"from\",\n    get: function get() {\n      return this.context.start + this.context.buffer.buffer[this.index + 1];\n    }\n  }, {\n    key: \"to\",\n    get: function get() {\n      return this.context.start + this.context.buffer.buffer[this.index + 2];\n    }\n  }, {\n    key: \"child\",\n    value: function child(dir, pos, side) {\n      var buffer = this.context.buffer;\n      var index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n      return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.child(1, 0, 4 /* Side.DontCare */);\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.child(-1, 0, 4 /* Side.DontCare */);\n    }\n  }, {\n    key: \"childAfter\",\n    value: function childAfter(pos) {\n      return this.child(1, pos, 2 /* Side.After */);\n    }\n  }, {\n    key: \"childBefore\",\n    value: function childBefore(pos) {\n      return this.child(-1, pos, -2 /* Side.Before */);\n    }\n  }, {\n    key: \"enter\",\n    value: function enter(pos, side) {\n      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      if (mode & IterMode.ExcludeBuffers) return null;\n      var buffer = this.context.buffer;\n      var index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n      return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._parent || this.context.parent.nextSignificantParent();\n    }\n  }, {\n    key: \"externalSibling\",\n    value: function externalSibling(dir) {\n      return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      var buffer = this.context.buffer;\n      var after = buffer.buffer[this.index + 3];\n      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);\n      return this.externalSibling(1);\n    }\n  }, {\n    key: \"prevSibling\",\n    get: function get() {\n      var buffer = this.context.buffer;\n      var parentStart = this._parent ? this._parent.index + 4 : 0;\n      if (this.index == parentStart) return this.externalSibling(-1);\n      return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n    }\n  }, {\n    key: \"cursor\",\n    value: function cursor() {\n      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return new TreeCursor(this, mode);\n    }\n  }, {\n    key: \"tree\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"toTree\",\n    value: function toTree() {\n      var children = [],\n        positions = [];\n      var buffer = this.context.buffer;\n      var startI = this.index + 4,\n        endI = buffer.buffer[this.index + 3];\n      if (endI > startI) {\n        var from = buffer.buffer[this.index + 1];\n        children.push(buffer.slice(startI, endI, from));\n        positions.push(0);\n      }\n      return new Tree(this.type, children, positions, this.to - this.from);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return resolveNode(this, pos, side, false);\n    }\n  }, {\n    key: \"resolveInner\",\n    value: function resolveInner(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return resolveNode(this, pos, side, true);\n    }\n  }, {\n    key: \"enterUnfinishedNodesBefore\",\n    value: function enterUnfinishedNodesBefore(pos) {\n      return _enterUnfinishedNodesBefore(this, pos);\n    }\n    /// @internal\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.context.buffer.childString(this.index);\n    }\n  }, {\n    key: \"getChild\",\n    value: function getChild(type) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var r = _getChildren(this, type, before, after);\n      return r.length ? r[0] : null;\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(type) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      return _getChildren(this, type, before, after);\n    }\n  }, {\n    key: \"node\",\n    get: function get() {\n      return this;\n    }\n  }, {\n    key: \"matchContext\",\n    value: function matchContext(context) {\n      return matchNodeContext(this, context);\n    }\n  }]);\n  return BufferNode;\n}(); /// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nvar TreeCursor = /*#__PURE__*/function () {\n  /// @internal\n  function TreeCursor(node) {\n    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    _classCallCheck(this, TreeCursor);\n    this.mode = mode;\n    /// @internal\n    this.buffer = null;\n    this.stack = [];\n    /// @internal\n    this.index = 0;\n    this.bufferNode = null;\n    if (node instanceof TreeNode) {\n      this.yieldNode(node);\n    } else {\n      this._tree = node.context.parent;\n      this.buffer = node.context;\n      for (var n = node._parent; n; n = n._parent) this.stack.unshift(n.index);\n      this.bufferNode = node;\n      this.yieldBuf(node.index);\n    }\n  }\n  _createClass(TreeCursor, [{\n    key: \"name\",\n    get:\n    /// Shorthand for `.type.name`.\n    function get() {\n      return this.type.name;\n    }\n  }, {\n    key: \"yieldNode\",\n    value: function yieldNode(node) {\n      if (!node) return false;\n      this._tree = node;\n      this.type = node.type;\n      this.from = node.from;\n      this.to = node.to;\n      return true;\n    }\n  }, {\n    key: \"yieldBuf\",\n    value: function yieldBuf(index, type) {\n      this.index = index;\n      var _this$buffer = this.buffer,\n        start = _this$buffer.start,\n        buffer = _this$buffer.buffer;\n      this.type = type || buffer.set.types[buffer.buffer[index]];\n      this.from = start + buffer.buffer[index + 1];\n      this.to = start + buffer.buffer[index + 2];\n      return true;\n    }\n  }, {\n    key: \"yield\",\n    value: function _yield(node) {\n      if (!node) return false;\n      if (node instanceof TreeNode) {\n        this.buffer = null;\n        return this.yieldNode(node);\n      }\n      this.buffer = node.context;\n      return this.yieldBuf(node.index, node.type);\n    }\n    /// @internal\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /// @internal\n  }, {\n    key: \"enterChild\",\n    value: function enterChild(dir, pos, side) {\n      if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n      var buffer = this.buffer.buffer;\n      var index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n      if (index < 0) return false;\n      this.stack.push(this.index);\n      return this.yieldBuf(index);\n    }\n    /// Move the cursor to this node's first child. When this returns\n    /// false, the node has no child, and the cursor has not been moved.\n  }, {\n    key: \"firstChild\",\n    value: function firstChild() {\n      return this.enterChild(1, 0, 4 /* Side.DontCare */);\n    }\n    /// Move the cursor to this node's last child.\n  }, {\n    key: \"lastChild\",\n    value: function lastChild() {\n      return this.enterChild(-1, 0, 4 /* Side.DontCare */);\n    }\n    /// Move the cursor to the first child that ends after `pos`.\n  }, {\n    key: \"childAfter\",\n    value: function childAfter(pos) {\n      return this.enterChild(1, pos, 2 /* Side.After */);\n    }\n    /// Move to the last child that starts before `pos`.\n  }, {\n    key: \"childBefore\",\n    value: function childBefore(pos) {\n      return this.enterChild(-1, pos, -2 /* Side.Before */);\n    }\n    /// Move the cursor to the child around `pos`. If side is -1 the\n    /// child may end at that position, when 1 it may start there. This\n    /// will also enter [overlaid](#common.MountedTree.overlay)\n    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    /// set to false.\n  }, {\n    key: \"enter\",\n    value: function enter(pos, side) {\n      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.mode;\n      if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode));\n      return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /// Move to the node's parent node, if this isn't the top node.\n  }, {\n    key: \"parent\",\n    value: function parent() {\n      if (!this.buffer) return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);\n      if (this.stack.length) return this.yieldBuf(this.stack.pop());\n      var parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n      this.buffer = null;\n      return this.yieldNode(parent);\n    }\n    /// @internal\n  }, {\n    key: \"sibling\",\n    value: function sibling(dir) {\n      if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));\n      var buffer = this.buffer.buffer,\n        d = this.stack.length - 1;\n      if (dir < 0) {\n        var parentStart = d < 0 ? 0 : this.stack[d] + 4;\n        if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n      } else {\n        var after = buffer.buffer[this.index + 3];\n        if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);\n      }\n      return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;\n    }\n    /// Move to this node's next sibling, if any.\n  }, {\n    key: \"nextSibling\",\n    value: function nextSibling() {\n      return this.sibling(1);\n    }\n    /// Move to this node's previous sibling, if any.\n  }, {\n    key: \"prevSibling\",\n    value: function prevSibling() {\n      return this.sibling(-1);\n    }\n  }, {\n    key: \"atLastNode\",\n    value: function atLastNode(dir) {\n      var index,\n        parent,\n        buffer = this.buffer;\n      if (buffer) {\n        if (dir > 0) {\n          if (this.index < buffer.buffer.buffer.length) return false;\n        } else {\n          for (var i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false;\n        }\n        index = buffer.index;\n        parent = buffer.parent;\n      } else {\n        var _this$_tree = this._tree;\n        index = _this$_tree.index;\n        parent = _this$_tree._parent;\n      }\n      for (; parent; _parent3 = parent, index = _parent3.index, parent = _parent3._parent, _parent3) {\n        var _parent3;\n        if (index > -1) for (var _i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; _i != e; _i += dir) {\n          var child = parent._tree.children[_i];\n          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"move\",\n    value: function move(dir, enter) {\n      if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */)) return true;\n      for (;;) {\n        if (this.sibling(dir)) return true;\n        if (this.atLastNode(dir) || !this.parent()) return false;\n      }\n    }\n    /// Move to the next node in a\n    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n    /// traversal, going from a node to its first child or, if the\n    /// current node is empty or `enter` is false, its next sibling or\n    /// the next sibling of the first parent node that has one.\n  }, {\n    key: \"next\",\n    value: function next() {\n      var enter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return this.move(1, enter);\n    }\n    /// Move to the next node in a last-to-first pre-order traveral. A\n    /// node is followed by its last child or, if it has none, its\n    /// previous sibling or the previous sibling of the first parent\n    /// node that has one.\n  }, {\n    key: \"prev\",\n    value: function prev() {\n      var enter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return this.move(-1, enter);\n    }\n    /// Move the cursor to the innermost node that covers `pos`. If\n    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    /// it will enter nodes that start at `pos`.\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      // Move up to a node that actually holds the position, if possible\n      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) if (!this.parent()) break;\n      // Then scan down into child nodes as far as possible\n      while (this.enterChild(1, pos, side)) {}\n      return this;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    /// position.\n  }, {\n    key: \"node\",\n    get: function get() {\n      if (!this.buffer) return this._tree;\n      var cache = this.bufferNode,\n        result = null,\n        depth = 0;\n      if (cache && cache.context == this.buffer) {\n        scan: for (var index = this.index, d = this.stack.length; d >= 0;) {\n          for (var c = cache; c; c = c._parent) if (c.index == index) {\n            if (index == this.index) return c;\n            result = c;\n            depth = d + 1;\n            break scan;\n          }\n          index = this.stack[--d];\n        }\n      }\n      for (var i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i]);\n      return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /// Get the [tree](#common.Tree) that represents the current node, if\n    /// any. Will return null when the node is in a [tree\n    /// buffer](#common.TreeBuffer).\n  }, {\n    key: \"tree\",\n    get: function get() {\n      return this.buffer ? null : this._tree._tree;\n    }\n    /// Iterate over the current node and all its descendants, calling\n    /// `enter` when entering a node and `leave`, if given, when leaving\n    /// one. When `enter` returns `false`, any children of that node are\n    /// skipped, and `leave` isn't called for it.\n  }, {\n    key: \"iterate\",\n    value: function iterate(enter, leave) {\n      for (var depth = 0;;) {\n        var mustLeave = false;\n        if (this.type.isAnonymous || enter(this) !== false) {\n          if (this.firstChild()) {\n            depth++;\n            continue;\n          }\n          if (!this.type.isAnonymous) mustLeave = true;\n        }\n        for (;;) {\n          if (mustLeave && leave) leave(this);\n          mustLeave = this.type.isAnonymous;\n          if (this.nextSibling()) break;\n          if (!depth) return;\n          this.parent();\n          depth--;\n          mustLeave = true;\n        }\n      }\n    }\n    /// Test whether the current node matches a given contexta sequence\n    /// of direct parent node names. Empty strings in the context array\n    /// are treated as wildcards.\n  }, {\n    key: \"matchContext\",\n    value: function matchContext(context) {\n      if (!this.buffer) return matchNodeContext(this.node, context);\n      var buffer = this.buffer.buffer,\n        types = buffer.set.types;\n      for (var i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {\n        if (d < 0) return matchNodeContext(this.node, context, i);\n        var type = types[buffer.buffer[this.stack[d]]];\n        if (!type.isAnonymous) {\n          if (context[i] && context[i] != type.name) return false;\n          i--;\n        }\n      }\n      return true;\n    }\n  }]);\n  return TreeCursor;\n}();\nfunction hasChild(tree) {\n  return tree.children.some(function (ch) {\n    return ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch);\n  });\n}\nfunction buildTree(data) {\n  var _a;\n  var buffer = data.buffer,\n    nodeSet = data.nodeSet,\n    _data$maxBufferLength = data.maxBufferLength,\n    maxBufferLength = _data$maxBufferLength === void 0 ? DefaultBufferLength : _data$maxBufferLength,\n    _data$reused = data.reused,\n    reused = _data$reused === void 0 ? [] : _data$reused,\n    _data$minRepeatType = data.minRepeatType,\n    minRepeatType = _data$minRepeatType === void 0 ? nodeSet.types.length : _data$minRepeatType;\n  var cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n  var types = nodeSet.types;\n  var contextHash = 0,\n    lookAhead = 0;\n  function takeNode(parentStart, minPos, children, positions, inRepeat) {\n    var id = cursor.id,\n      start = cursor.start,\n      end = cursor.end,\n      size = cursor.size;\n    var lookAheadAtStart = lookAhead;\n    while (size < 0) {\n      cursor.next();\n      if (size == -1 /* SpecialRecord.Reuse */) {\n        var _node = reused[id];\n        children.push(_node);\n        positions.push(start - parentStart);\n        return;\n      } else if (size == -3 /* SpecialRecord.ContextChange */) {\n        // Context change\n        contextHash = id;\n        return;\n      } else if (size == -4 /* SpecialRecord.LookAhead */) {\n        lookAhead = id;\n        return;\n      } else {\n        throw new RangeError(\"Unrecognized record size: \".concat(size));\n      }\n    }\n    var type = types[id],\n      node,\n      buffer;\n    var startPos = start - parentStart;\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n      // Small enough for a buffer, and no reused nodes inside\n      var _data = new Uint16Array(buffer.size - buffer.skip);\n      var endPos = cursor.pos - buffer.size,\n        index = _data.length;\n      while (cursor.pos > endPos) index = copyToBuffer(buffer.start, _data, index);\n      node = new TreeBuffer(_data, end - buffer.start, nodeSet);\n      startPos = buffer.start - parentStart;\n    } else {\n      // Make it a node\n      var _endPos = cursor.pos - size;\n      cursor.next();\n      var localChildren = [],\n        localPositions = [];\n      var localInRepeat = id >= minRepeatType ? id : -1;\n      var lastGroup = 0,\n        lastEnd = end;\n      while (cursor.pos > _endPos) {\n        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n          if (cursor.end <= lastEnd - maxBufferLength) {\n            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n            lastGroup = localChildren.length;\n            lastEnd = cursor.end;\n          }\n          cursor.next();\n        } else {\n          takeNode(start, _endPos, localChildren, localPositions, localInRepeat);\n        }\n      }\n      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n      localChildren.reverse();\n      localPositions.reverse();\n      if (localInRepeat > -1 && lastGroup > 0) {\n        var make = makeBalanced(type);\n        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n      } else {\n        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n      }\n    }\n    children.push(node);\n    positions.push(startPos);\n  }\n  function makeBalanced(type) {\n    return function (children, positions, length) {\n      var lookAhead = 0,\n        lastI = children.length - 1,\n        last,\n        lookAheadProp;\n      if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n        if (!lastI && last.type == type && last.length == length) return last;\n        if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead = positions[lastI] + last.length + lookAheadProp;\n      }\n      return makeTree(type, children, positions, length, lookAhead);\n    };\n  }\n  function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n    var localChildren = [],\n      localPositions = [];\n    while (children.length > i) {\n      localChildren.push(children.pop());\n      localPositions.push(positions.pop() + base - from);\n    }\n    children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n    positions.push(from - base);\n  }\n  function makeTree(type, children, positions, length) {\n    var lookAhead = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var props = arguments.length > 5 ? arguments[5] : undefined;\n    if (contextHash) {\n      var pair = [NodeProp.contextHash, contextHash];\n      props = props ? [pair].concat(props) : [pair];\n    }\n    if (lookAhead > 25) {\n      var _pair = [NodeProp.lookAhead, lookAhead];\n      props = props ? [_pair].concat(props) : [_pair];\n    }\n    return new Tree(type, children, positions, length, props);\n  }\n  function findBufferSize(maxSize, inRepeat) {\n    // Scan through the buffer to find previous siblings that fit\n    // together in a TreeBuffer, and don't contain any reused nodes\n    // (which can't be stored in a buffer).\n    // If `inRepeat` is > -1, ignore node boundaries of that type for\n    // nesting, but make sure the end falls either at the start\n    // (`maxSize`) or before such a node.\n    var fork = cursor.fork();\n    var size = 0,\n      start = 0,\n      skip = 0,\n      minStart = fork.end - maxBufferLength;\n    var result = {\n      size: 0,\n      start: 0,\n      skip: 0\n    };\n    scan: for (var minPos = fork.pos - maxSize; fork.pos > minPos;) {\n      var _nodeSize = fork.size;\n      // Pretend nested repeat nodes of the same type don't exist\n      if (fork.id == inRepeat && _nodeSize >= 0) {\n        // Except that we store the current state as a valid return\n        // value.\n        result.size = size;\n        result.start = start;\n        result.skip = skip;\n        skip += 4;\n        size += 4;\n        fork.next();\n        continue;\n      }\n      var startPos = fork.pos - _nodeSize;\n      if (_nodeSize < 0 || startPos < minPos || fork.start < minStart) break;\n      var localSkipped = fork.id >= minRepeatType ? 4 : 0;\n      var nodeStart = fork.start;\n      fork.next();\n      while (fork.pos > startPos) {\n        if (fork.size < 0) {\n          if (fork.size == -3 /* SpecialRecord.ContextChange */) localSkipped += 4;else break scan;\n        } else if (fork.id >= minRepeatType) {\n          localSkipped += 4;\n        }\n        fork.next();\n      }\n      start = nodeStart;\n      size += _nodeSize;\n      skip += localSkipped;\n    }\n    if (inRepeat < 0 || size == maxSize) {\n      result.size = size;\n      result.start = start;\n      result.skip = skip;\n    }\n    return result.size > 4 ? result : undefined;\n  }\n  function copyToBuffer(bufferStart, buffer, index) {\n    var id = cursor.id,\n      start = cursor.start,\n      end = cursor.end,\n      size = cursor.size;\n    cursor.next();\n    if (size >= 0 && id < minRepeatType) {\n      var startIndex = index;\n      if (size > 4) {\n        var endPos = cursor.pos - (size - 4);\n        while (cursor.pos > endPos) index = copyToBuffer(bufferStart, buffer, index);\n      }\n      buffer[--index] = startIndex;\n      buffer[--index] = end - bufferStart;\n      buffer[--index] = start - bufferStart;\n      buffer[--index] = id;\n    } else if (size == -3 /* SpecialRecord.ContextChange */) {\n      contextHash = id;\n    } else if (size == -4 /* SpecialRecord.LookAhead */) {\n      lookAhead = id;\n    }\n    return index;\n  }\n  var children = [],\n    positions = [];\n  while (cursor.pos > 0) takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);\n  var length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;\n  return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nvar nodeSizeCache = new WeakMap();\nfunction nodeSize(balanceType, node) {\n  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;\n  var size = nodeSizeCache.get(node);\n  if (size == null) {\n    size = 1;\n    var _iterator8 = _createForOfIteratorHelper(node.children),\n      _step8;\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var child = _step8.value;\n        if (child.type != balanceType || !(child instanceof Tree)) {\n          size = 1;\n          break;\n        }\n        size += nodeSize(balanceType, child);\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n    nodeSizeCache.set(node, size);\n  }\n  return size;\n}\nfunction balanceRange(\n// The type the balanced tree's inner nodes.\nbalanceType,\n// The direct children and their positions\nchildren, positions,\n// The index range in children/positions to use\nfrom, to,\n// The start position of the nodes, relative to their parent.\nstart,\n// Length of the outer node\nlength,\n// Function to build the top node of the balanced tree\nmkTop,\n// Function to build internal nodes for the balanced tree\nmkTree) {\n  var total = 0;\n  for (var i = from; i < to; i++) total += nodeSize(balanceType, children[i]);\n  var maxChild = Math.ceil(total * 1.5 / 8 /* Balance.BranchFactor */);\n  var localChildren = [],\n    localPositions = [];\n  function divide(children, positions, from, to, offset) {\n    for (var _i2 = from; _i2 < to;) {\n      var groupFrom = _i2,\n        groupStart = positions[_i2],\n        groupSize = nodeSize(balanceType, children[_i2]);\n      _i2++;\n      for (; _i2 < to; _i2++) {\n        var nextSize = nodeSize(balanceType, children[_i2]);\n        if (groupSize + nextSize >= maxChild) break;\n        groupSize += nextSize;\n      }\n      if (_i2 == groupFrom + 1) {\n        if (groupSize > maxChild) {\n          var only = children[groupFrom]; // Only trees can have a size > 1\n          divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n          continue;\n        }\n        localChildren.push(children[groupFrom]);\n      } else {\n        var _length = positions[_i2 - 1] + children[_i2 - 1].length - groupStart;\n        localChildren.push(balanceRange(balanceType, children, positions, groupFrom, _i2, groupStart, _length, null, mkTree));\n      }\n      localPositions.push(groupStart + offset - start);\n    }\n  }\n  divide(children, positions, from, to, 0);\n  return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/// Provides a way to associate values with pieces of trees. As long\n/// as that part of the tree is reused, the associated values can be\n/// retrieved from an updated tree.\nvar NodeWeakMap = /*#__PURE__*/function () {\n  function NodeWeakMap() {\n    _classCallCheck(this, NodeWeakMap);\n    this.map = new WeakMap();\n  }\n  _createClass(NodeWeakMap, [{\n    key: \"setBuffer\",\n    value: function setBuffer(buffer, index, value) {\n      var inner = this.map.get(buffer);\n      if (!inner) this.map.set(buffer, inner = new Map());\n      inner.set(index, value);\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer(buffer, index) {\n      var inner = this.map.get(buffer);\n      return inner && inner.get(index);\n    }\n    /// Set the value for this syntax node.\n  }, {\n    key: \"set\",\n    value: function set(node, value) {\n      if (node instanceof BufferNode) this.setBuffer(node.context.buffer, node.index, value);else if (node instanceof TreeNode) this.map.set(node.tree, value);\n    }\n    /// Retrieve value for this syntax node, if it exists in the map.\n  }, {\n    key: \"get\",\n    value: function get(node) {\n      return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /// Set the value for the node that a cursor currently points to.\n  }, {\n    key: \"cursorSet\",\n    value: function cursorSet(cursor, value) {\n      if (cursor.buffer) this.setBuffer(cursor.buffer.buffer, cursor.index, value);else this.map.set(cursor.tree, value);\n    }\n    /// Retrieve the value for the node that a cursor currently points\n    /// to.\n  }, {\n    key: \"cursorGet\",\n    value: function cursorGet(cursor) {\n      return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n  }]);\n  return NodeWeakMap;\n}(); /// Tree fragments are used during [incremental\n/// parsing](#common.Parser.startParse) to track parts of old trees\n/// that can be reused in a new parse. An array of fragments is used\n/// to track regions of an old tree whose nodes might be reused in new\n/// parses. Use the static\n/// [`applyChanges`](#common.TreeFragment^applyChanges) method to\n/// update fragments for document changes.\nvar TreeFragment = /*#__PURE__*/function () {\n  /// Construct a tree fragment. You'll usually want to use\n  /// [`addTree`](#common.TreeFragment^addTree) and\n  /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n  /// calling this directly.\n  function TreeFragment(\n  /// The start of the unchanged range pointed to by this fragment.\n  /// This refers to an offset in the _updated_ document (as opposed\n  /// to the original tree).\n  from,\n  /// The end of the unchanged range.\n  to,\n  /// The tree that this fragment is based on.\n  tree,\n  /// The offset between the fragment's tree and the document that\n  /// this fragment can be used against. Add this when going from\n  /// document to tree positions, subtract it to go from tree to\n  /// document positions.\n  offset) {\n    var openStart = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    var openEnd = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    _classCallCheck(this, TreeFragment);\n    this.from = from;\n    this.to = to;\n    this.tree = tree;\n    this.offset = offset;\n    this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);\n  }\n  /// Whether the start of the fragment represents the start of a\n  /// parse, or the end of a change. (In the second case, it may not\n  /// be safe to reuse some nodes at the start, depending on the\n  /// parsing algorithm.)\n  _createClass(TreeFragment, [{\n    key: \"openStart\",\n    get: function get() {\n      return (this.open & 1 /* Open.Start */) > 0;\n    }\n    /// Whether the end of the fragment represents the end of a\n    /// full-document parse, or the start of a change.\n  }, {\n    key: \"openEnd\",\n    get: function get() {\n      return (this.open & 2 /* Open.End */) > 0;\n    }\n    /// Create a set of fragments from a freshly parsed tree, or update\n    /// an existing set of fragments by replacing the ones that overlap\n    /// with a tree with content from the new tree. When `partial` is\n    /// true, the parse is treated as incomplete, and the resulting\n    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    /// true.\n  }], [{\n    key: \"addTree\",\n    value: function addTree(tree) {\n      var fragments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var partial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n      var _iterator9 = _createForOfIteratorHelper(fragments),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var f = _step9.value;\n          if (f.to > tree.length) result.push(f);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      return result;\n    }\n    /// Apply a set of edits to an array of fragments, removing or\n    /// splitting fragments as necessary to remove edited ranges, and\n    /// adjusting offsets for fragments that moved.\n  }, {\n    key: \"applyChanges\",\n    value: function applyChanges(fragments, changes) {\n      var minGap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 128;\n      if (!changes.length) return fragments;\n      var result = [];\n      var fI = 1,\n        nextF = fragments.length ? fragments[0] : null;\n      for (var cI = 0, pos = 0, off = 0;; cI++) {\n        var nextC = cI < changes.length ? changes[cI] : null;\n        var nextPos = nextC ? nextC.fromA : 1e9;\n        if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {\n          var cut = nextF;\n          if (pos >= cut.from || nextPos <= cut.to || off) {\n            var fFrom = Math.max(cut.from, pos) - off,\n              fTo = Math.min(cut.to, nextPos) - off;\n            cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n          }\n          if (cut) result.push(cut);\n          if (nextF.to > nextPos) break;\n          nextF = fI < fragments.length ? fragments[fI++] : null;\n        }\n        if (!nextC) break;\n        pos = nextC.toA;\n        off = nextC.toA - nextC.toB;\n      }\n      return result;\n    }\n  }]);\n  return TreeFragment;\n}(); /// A superclass that parsers should extend.\nvar Parser = /*#__PURE__*/function () {\n  function Parser() {\n    _classCallCheck(this, Parser);\n  }\n  _createClass(Parser, [{\n    key: \"startParse\",\n    value:\n    /// Start a parse, returning a [partial parse](#common.PartialParse)\n    /// object. [`fragments`](#common.TreeFragment) can be passed in to\n    /// make the parse incremental.\n    ///\n    /// By default, the entire input is parsed. You can pass `ranges`,\n    /// which should be a sorted array of non-empty, non-overlapping\n    /// ranges, to parse only those ranges. The tree returned in that\n    /// case will start at `ranges[0].from`.\n    function startParse(input, fragments, ranges) {\n      if (typeof input == \"string\") input = new StringInput(input);\n      ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(function (r) {\n        return new Range(r.from, r.to);\n      }) : [new Range(0, 0)];\n      return this.createParse(input, fragments || [], ranges);\n    }\n    /// Run a full parse, returning the resulting tree.\n  }, {\n    key: \"parse\",\n    value: function parse(input, fragments, ranges) {\n      var parse = this.startParse(input, fragments, ranges);\n      for (;;) {\n        var done = parse.advance();\n        if (done) return done;\n      }\n    }\n  }]);\n  return Parser;\n}();\nvar StringInput = /*#__PURE__*/function () {\n  function StringInput(string) {\n    _classCallCheck(this, StringInput);\n    this.string = string;\n  }\n  _createClass(StringInput, [{\n    key: \"length\",\n    get: function get() {\n      return this.string.length;\n    }\n  }, {\n    key: \"chunk\",\n    value: function chunk(from) {\n      return this.string.slice(from);\n    }\n  }, {\n    key: \"lineChunks\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"read\",\n    value: function read(from, to) {\n      return this.string.slice(from, to);\n    }\n  }]);\n  return StringInput;\n}(); /// Create a parse wrapper that, after the inner parse completes,\n/// scans its tree for mixed language regions with the `nest`\n/// function, runs the resulting [inner parses](#common.NestedParse),\n/// and then [mounts](#common.NodeProp^mounted) their results onto the\n/// tree.\nfunction parseMixed(nest) {\n  return function (parse, input, fragments, ranges) {\n    return new MixedParse(parse, nest, input, fragments, ranges);\n  };\n}\nvar InnerParse = /*#__PURE__*/_createClass(function InnerParse(parser, parse, overlay, target, ranges) {\n  _classCallCheck(this, InnerParse);\n  this.parser = parser;\n  this.parse = parse;\n  this.overlay = overlay;\n  this.target = target;\n  this.ranges = ranges;\n});\nvar ActiveOverlay = /*#__PURE__*/_createClass(function ActiveOverlay(parser, predicate, mounts, index, start, target, prev) {\n  _classCallCheck(this, ActiveOverlay);\n  this.parser = parser;\n  this.predicate = predicate;\n  this.mounts = mounts;\n  this.index = index;\n  this.start = start;\n  this.target = target;\n  this.prev = prev;\n  this.depth = 0;\n  this.ranges = [];\n});\nvar stoppedInner = new NodeProp({\n  perNode: true\n});\nvar MixedParse = /*#__PURE__*/function () {\n  function MixedParse(base, nest, input, fragments, ranges) {\n    _classCallCheck(this, MixedParse);\n    this.nest = nest;\n    this.input = input;\n    this.fragments = fragments;\n    this.ranges = ranges;\n    this.inner = [];\n    this.innerDone = 0;\n    this.baseTree = null;\n    this.stoppedAt = null;\n    this.baseParse = base;\n  }\n  _createClass(MixedParse, [{\n    key: \"advance\",\n    value: function advance() {\n      if (this.baseParse) {\n        var _done = this.baseParse.advance();\n        if (!_done) return null;\n        this.baseParse = null;\n        this.baseTree = _done;\n        this.startInner();\n        if (this.stoppedAt != null) {\n          var _iterator10 = _createForOfIteratorHelper(this.inner),\n            _step10;\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var _inner = _step10.value;\n              _inner.parse.stopAt(this.stoppedAt);\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n        }\n      }\n      if (this.innerDone == this.inner.length) {\n        var result = this.baseTree;\n        if (this.stoppedAt != null) result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n        return result;\n      }\n      var inner = this.inner[this.innerDone],\n        done = inner.parse.advance();\n      if (done) {\n        this.innerDone++;\n        // This is a somewhat dodgy but super helpful hack where we\n        // patch up nodes created by the inner parse (and thus\n        // presumably not aliased anywhere else) to hold the information\n        // about the inner parse.\n        var props = Object.assign(Object.create(null), inner.target.props);\n        props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n        inner.target.props = props;\n      }\n      return null;\n    }\n  }, {\n    key: \"parsedPos\",\n    get: function get() {\n      if (this.baseParse) return 0;\n      var pos = this.input.length;\n      for (var i = this.innerDone; i < this.inner.length; i++) {\n        if (this.inner[i].ranges[0].from < pos) pos = Math.min(pos, this.inner[i].parse.parsedPos);\n      }\n      return pos;\n    }\n  }, {\n    key: \"stopAt\",\n    value: function stopAt(pos) {\n      this.stoppedAt = pos;\n      if (this.baseParse) this.baseParse.stopAt(pos);else for (var i = this.innerDone; i < this.inner.length; i++) this.inner[i].parse.stopAt(pos);\n    }\n  }, {\n    key: \"startInner\",\n    value: function startInner() {\n      var fragmentCursor = new FragmentCursor(this.fragments);\n      var overlay = null;\n      var covered = null;\n      var cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n      scan: for (var nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {\n        var enter = true,\n          range = void 0;\n        if (fragmentCursor.hasNode(cursor)) {\n          if (overlay) {\n            var match = overlay.mounts.find(function (m) {\n              return m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay;\n            });\n            if (match) {\n              var _iterator11 = _createForOfIteratorHelper(match.mount.overlay),\n                _step11;\n              try {\n                var _loop = function _loop() {\n                  var r = _step11.value;\n                  var from = r.from + match.pos,\n                    to = r.to + match.pos;\n                  if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(function (r) {\n                    return r.from < to && r.to > from;\n                  })) overlay.ranges.push({\n                    from: from,\n                    to: to\n                  });\n                };\n                for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                  _loop();\n                }\n              } catch (err) {\n                _iterator11.e(err);\n              } finally {\n                _iterator11.f();\n              }\n            }\n          }\n          enter = false;\n        } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n          enter = isCovered != 2 /* Cover.Full */;\n        } else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {\n          if (!cursor.tree) materialize(cursor);\n          var oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n          if (typeof nest.overlay == \"function\") {\n            overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n          } else {\n            var ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);\n            if (ranges.length) this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(function (r) {\n              return new Range(r.from - cursor.from, r.to - cursor.from);\n            }) : null, cursor.tree, ranges));\n            if (!nest.overlay) enter = false;else if (ranges.length) covered = {\n              ranges: ranges,\n              depth: 0,\n              prev: covered\n            };\n          }\n        } else if (overlay && (range = overlay.predicate(cursor))) {\n          if (range === true) range = new Range(cursor.from, cursor.to);\n          if (range.from < range.to) overlay.ranges.push(range);\n        }\n        if (enter && cursor.firstChild()) {\n          if (overlay) overlay.depth++;\n          if (covered) covered.depth++;\n        } else {\n          for (;;) {\n            if (cursor.nextSibling()) break;\n            if (!cursor.parent()) break scan;\n            if (overlay && ! --overlay.depth) {\n              var _ranges = punchRanges(this.ranges, overlay.ranges);\n              if (_ranges.length) this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, _ranges), _ranges), overlay.ranges.map(function (r) {\n                return new Range(r.from - overlay.start, r.to - overlay.start);\n              }), overlay.target, _ranges));\n              overlay = overlay.prev;\n            }\n            if (covered && ! --covered.depth) covered = covered.prev;\n          }\n        }\n      }\n    }\n  }]);\n  return MixedParse;\n}();\nfunction checkCover(covered, from, to) {\n  var _iterator12 = _createForOfIteratorHelper(covered),\n    _step12;\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var range = _step12.value;\n      if (range.from >= to) break;\n      if (range.to > from) return range.from <= from && range.to >= to ? 2 /* Cover.Full */ : 1 /* Cover.Partial */;\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n  return 0 /* Cover.None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n  if (startI < endI) {\n    var from = buf.buffer[startI + 1];\n    nodes.push(buf.slice(startI, endI, from));\n    positions.push(from - off);\n  }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n  var node = cursor.node,\n    depth = 0;\n  // Scan up to the nearest tree\n  do {\n    cursor.parent();\n    depth++;\n  } while (!cursor.tree);\n  // Find the index of the buffer in that tree\n  var i = 0,\n    base = cursor.tree,\n    off = 0;\n  for (;; i++) {\n    off = base.positions[i] + cursor.from;\n    if (off <= node.from && off + base.children[i].length >= node.to) break;\n  }\n  var buf = base.children[i],\n    b = buf.buffer;\n  // Split a level in the buffer, putting the nodes before and after\n  // the child that contains `node` into new buffers.\n  function split(startI, endI, type, innerOffset, length) {\n    var i = startI;\n    while (b[i + 2] + off <= node.from) i = b[i + 3];\n    var children = [],\n      positions = [];\n    sliceBuf(buf, startI, i, children, positions, innerOffset);\n    var from = b[i + 1],\n      to = b[i + 2];\n    var isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;\n    children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));\n    positions.push(from - innerOffset);\n    sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);\n    return new Tree(type, children, positions, length);\n  }\n  base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);\n  // Move the cursor back to the target node\n  for (var d = 0; d <= depth; d++) cursor.childAfter(node.from);\n}\nvar StructureCursor = /*#__PURE__*/function () {\n  function StructureCursor(root, offset) {\n    _classCallCheck(this, StructureCursor);\n    this.offset = offset;\n    this.done = false;\n    this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n  }\n  // Move to the first node (in pre-order) that starts at or after `pos`.\n  _createClass(StructureCursor, [{\n    key: \"moveTo\",\n    value: function moveTo(pos) {\n      var cursor = this.cursor,\n        p = pos - this.offset;\n      while (!this.done && cursor.from < p) {\n        if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;else if (!cursor.next(false)) this.done = true;\n      }\n    }\n  }, {\n    key: \"hasNode\",\n    value: function hasNode(cursor) {\n      this.moveTo(cursor.from);\n      if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n        for (var tree = this.cursor.tree;;) {\n          if (tree == cursor.tree) return true;\n          if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree) tree = tree.children[0];else break;\n        }\n      }\n      return false;\n    }\n  }]);\n  return StructureCursor;\n}();\nvar FragmentCursor = /*#__PURE__*/function () {\n  function FragmentCursor(fragments) {\n    _classCallCheck(this, FragmentCursor);\n    var _a;\n    this.fragments = fragments;\n    this.curTo = 0;\n    this.fragI = 0;\n    if (fragments.length) {\n      var first = this.curFrag = fragments[0];\n      this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n      this.inner = new StructureCursor(first.tree, -first.offset);\n    } else {\n      this.curFrag = this.inner = null;\n    }\n  }\n  _createClass(FragmentCursor, [{\n    key: \"hasNode\",\n    value: function hasNode(node) {\n      while (this.curFrag && node.from >= this.curTo) this.nextFrag();\n      return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n  }, {\n    key: \"nextFrag\",\n    value: function nextFrag() {\n      var _a;\n      this.fragI++;\n      if (this.fragI == this.fragments.length) {\n        this.curFrag = this.inner = null;\n      } else {\n        var frag = this.curFrag = this.fragments[this.fragI];\n        this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n        this.inner = new StructureCursor(frag.tree, -frag.offset);\n      }\n    }\n  }, {\n    key: \"findMounts\",\n    value: function findMounts(pos, parser) {\n      var _a;\n      var result = [];\n      if (this.inner) {\n        this.inner.cursor.moveTo(pos, 1);\n        for (var _pos = this.inner.cursor.node; _pos; _pos = _pos.parent) {\n          var mount = (_a = _pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n          if (mount && mount.parser == parser) {\n            for (var i = this.fragI; i < this.fragments.length; i++) {\n              var frag = this.fragments[i];\n              if (frag.from >= _pos.to) break;\n              if (frag.tree == this.curFrag.tree) result.push({\n                frag: frag,\n                pos: _pos.from - frag.offset,\n                mount: mount\n              });\n            }\n          }\n        }\n      }\n      return result;\n    }\n  }]);\n  return FragmentCursor;\n}();\nfunction punchRanges(outer, ranges) {\n  var copy = null,\n    current = ranges;\n  for (var i = 1, j = 0; i < outer.length; i++) {\n    var gapFrom = outer[i - 1].to,\n      gapTo = outer[i].from;\n    for (; j < current.length; j++) {\n      var r = current[j];\n      if (r.from >= gapTo) break;\n      if (r.to <= gapFrom) continue;\n      if (!copy) current = copy = ranges.slice();\n      if (r.from < gapFrom) {\n        copy[j] = new Range(r.from, gapFrom);\n        if (r.to > gapTo) copy.splice(j + 1, 0, new Range(gapTo, r.to));\n      } else if (r.to > gapTo) {\n        copy[j--] = new Range(gapTo, r.to);\n      } else {\n        copy.splice(j--, 1);\n      }\n    }\n  }\n  return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n  var iA = 0,\n    iB = 0,\n    inA = false,\n    inB = false,\n    pos = -1e9;\n  var result = [];\n  for (;;) {\n    var nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n    var nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n    if (inA != inB) {\n      var start = Math.max(pos, from),\n        end = Math.min(nextA, nextB, to);\n      if (start < end) result.push(new Range(start, end));\n    }\n    pos = Math.min(nextA, nextB);\n    if (pos == 1e9) break;\n    if (nextA == pos) {\n      if (!inA) inA = true;else {\n        inA = false;\n        iA++;\n      }\n    }\n    if (nextB == pos) {\n      if (!inB) inB = true;else {\n        inB = false;\n        iB++;\n      }\n    }\n  }\n  return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n  var result = [];\n  var _iterator13 = _createForOfIteratorHelper(mounts),\n    _step13;\n  try {\n    var _loop2 = function _loop2() {\n      var _step13$value = _step13.value,\n        pos = _step13$value.pos,\n        mount = _step13$value.mount,\n        frag = _step13$value.frag;\n      var startPos = pos + (mount.overlay ? mount.overlay[0].from : 0),\n        endPos = startPos + mount.tree.length;\n      var from = Math.max(frag.from, startPos),\n        to = Math.min(frag.to, endPos);\n      if (mount.overlay) {\n        var overlay = mount.overlay.map(function (r) {\n          return new Range(r.from + pos, r.to + pos);\n        });\n        var changes = findCoverChanges(ranges, overlay, from, to);\n        for (var i = 0, _pos2 = from;; i++) {\n          var last = i == changes.length,\n            end = last ? to : changes[i].from;\n          if (end > _pos2) result.push(new TreeFragment(_pos2, end, mount.tree, -startPos, frag.from >= _pos2 || frag.openStart, frag.to <= end || frag.openEnd));\n          if (last) break;\n          _pos2 = changes[i].to;\n        }\n      } else {\n        result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n      }\n    };\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      _loop2();\n    }\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n  return result;\n}\nexport { DefaultBufferLength, IterMode, MountedTree, NodeProp, NodeSet, NodeType, NodeWeakMap, Parser, Tree, TreeBuffer, TreeCursor, TreeFragment, parseMixed };","map":{"version":3,"names":["DefaultBufferLength","nextPropID","Range","_createClass","from","to","_classCallCheck","NodeProp","config","arguments","length","undefined","id","perNode","deserialize","Error","key","value","add","match","_this","RangeError","NodeType","type","result","closedBy","str","split","openedBy","group","contextHash","lookAhead","mounted","MountedTree","tree","overlay","parser","noProps","Object","create","name","props","flags","prop","get","is","indexOf","define","spec","top","skipped","error","_iterator","_createForOfIteratorHelper","_step","s","n","done","src","Array","isArray","err","e","f","map","direct","_iterator2","_step2","node","groups","i","found","none","NodeSet","types","extend","newTypes","_len","_key","_iterator3","_step3","newProps","_iterator4","_step4","source","assign","push","CachedNode","WeakMap","CachedInnerNode","IterMode","Tree","children","positions","_iterator5","_step5","_step5$value","_slicedToArray","toString","_iterator6","_step6","ch","test","isError","JSON","stringify","cursor","mode","TreeCursor","topNode","cursorAt","pos","side","scope","moveTo","set","_tree","TreeNode","resolve","resolveNode","resolveInner","iterate","enter","leave","_spec$from","_spec$to","c","IncludeAnonymous","entered","isAnonymous","firstChild","nextSibling","parent","balance","_this2","balanceRange","propValues","makeTree","build","data","buildTree","empty","FlatBufferCursor","buffer","index","next","fork","TreeBuffer","childString","join","endIndex","findChild","startIndex","dir","pick","checkSide","slice","startI","endI","b","copy","Uint16Array","len","j","Math","max","enterUnfinishedNodesBefore","scan","childBefore","last","lastChild","prevSibling","overlays","_a","IgnoreOverlays","inner","_parent","nextChild","_parent$_tree","start","ExcludeBuffers","BufferNode","BufferContext","hasChild","IgnoreMounts","childAfter","rPos","_iterator7","_step7","_step7$value","nextSignificantParent","val","toTree","getChild","before","after","r","getChildren","matchContext","context","matchNodeContext","cur","p","child","externalSibling","parentStart","stack","bufferNode","yieldNode","unshift","yieldBuf","_this$buffer","_yield","enterChild","yield","pop","sibling","d","atLastNode","_this$_tree","_parent3","move","prev","cache","depth","mustLeave","some","nodeSet","_data$maxBufferLength","maxBufferLength","_data$reused","reused","_data$minRepeatType","minRepeatType","takeNode","minPos","inRepeat","end","size","lookAheadAtStart","concat","startPos","findBufferSize","skip","endPos","copyToBuffer","localChildren","localPositions","localInRepeat","lastGroup","lastEnd","makeRepeatLeaf","reverse","make","makeBalanced","lastI","lookAheadProp","base","pair","maxSize","minStart","nodeSize","localSkipped","nodeStart","bufferStart","topID","nodeSizeCache","balanceType","_iterator8","_step8","mkTop","mkTree","total","maxChild","ceil","divide","offset","groupFrom","groupStart","groupSize","nextSize","only","NodeWeakMap","setBuffer","Map","getBuffer","cursorSet","cursorGet","TreeFragment","openStart","openEnd","open","addTree","fragments","partial","_iterator9","_step9","applyChanges","changes","minGap","fI","nextF","cI","off","nextC","nextPos","fromA","cut","fFrom","fTo","min","toA","toB","Parser","startParse","input","ranges","StringInput","createParse","parse","advance","string","chunk","read","parseMixed","nest","MixedParse","InnerParse","target","ActiveOverlay","predicate","mounts","stoppedInner","innerDone","baseTree","stoppedAt","baseParse","startInner","_iterator10","_step10","stopAt","parsedPos","fragmentCursor","FragmentCursor","covered","isCovered","range","hasNode","find","m","frag","mount","_iterator11","_step11","_loop","checkCover","materialize","oldMounts","findMounts","punchRanges","enterFragments","splice","_iterator12","_step12","sliceBuf","buf","nodes","innerOffset","isTarget","StructureCursor","root","curTo","fragI","first","curFrag","nextFrag","outer","current","gapFrom","gapTo","findCoverChanges","a","iA","iB","inA","inB","nextA","nextB","_iterator13","_step13","_loop2","_step13$value"],"sources":["/Users/adityapethe/Developer/ui-chat/ui-chat/client/node_modules/@lezer/common/dist/index.js"],"sourcesContent":["// FIXME profile adding a per-Tree TreeNode cache, validating it by\n// parent pointer\n/// The default maximum length of a `TreeBuffer` node.\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n}\n/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)\n/// can have metadata associated with it in props. Instances of this\n/// class represent prop names.\nclass NodeProp {\n    /// Create a new node prop type.\n    constructor(config = {}) {\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /// This is meant to be used with\n    /// [`NodeSet.extend`](#common.NodeSet.extend) or\n    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    /// prop values for each node type in the set. Takes a [match\n    /// object](#common.NodeType^match) or function that returns undefined\n    /// if the node type doesn't get this prop, and the prop's value if\n    /// it does.\n    add(match) {\n        if (this.perNode)\n            throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\")\n            match = NodeType.match(match);\n        return (type) => {\n            let result = match(type);\n            return result === undefined ? null : [this, result];\n        };\n    }\n}\n/// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The hash of the [context](#lr.ContextTracker.constructor)\n/// that the node was parsed in, if any. Used to limit reuse of\n/// contextual nodes.\nNodeProp.contextHash = new NodeProp({ perNode: true });\n/// The distance beyond the end of the node that the tokenizer\n/// looked ahead for any of the tokens inside the node. (The LR\n/// parser only stores this when it is larger than 25, for\n/// efficiency reasons.)\nNodeProp.lookAhead = new NodeProp({ perNode: true });\n/// This per-node prop is used to replace a given node, or part of a\n/// node, with another tree. This is useful to include trees from\n/// different languages in mixed-language parsers.\nNodeProp.mounted = new NodeProp({ perNode: true });\n/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on\n/// a tree node to indicate that parts of its content are\n/// represented by another tree.\nclass MountedTree {\n    constructor(\n    /// The inner tree.\n    tree, \n    /// If this is null, this tree replaces the entire node (it will\n    /// be included in the regular iteration instead of its host\n    /// node). If not, only the given ranges are considered to be\n    /// covered by this tree. This is used for trees that are mixed in\n    /// a way that isn't strictly hierarchical. Such mounted trees are\n    /// only entered by [`resolveInner`](#common.Tree.resolveInner)\n    /// and [`enter`](#common.SyntaxNode.enter).\n    overlay, \n    /// The parser used to create this subtree.\n    parser) {\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n}\nconst noProps = Object.create(null);\n/// Each node in a syntax tree has a node type associated with it.\nclass NodeType {\n    /// @internal\n    constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    name, \n    /// @internal\n    props, \n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    id, \n    /// @internal\n    flags = 0) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    /// Define a node type.\n    static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) |\n            (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props)\n            for (let src of spec.props) {\n                if (!Array.isArray(src))\n                    src = src(type);\n                if (src) {\n                    if (src[0].perNode)\n                        throw new RangeError(\"Can't store a per-node prop on a node type\");\n                    props[src[0].id] = src[1];\n                }\n            }\n        return type;\n    }\n    /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    prop(prop) { return this.props[prop.id]; }\n    /// True when this is the top node of a grammar.\n    get isTop() { return (this.flags & 1 /* NodeFlag.Top */) > 0; }\n    /// True when this node is produced by a skip rule.\n    get isSkipped() { return (this.flags & 2 /* NodeFlag.Skipped */) > 0; }\n    /// Indicates whether this is an error node.\n    get isError() { return (this.flags & 4 /* NodeFlag.Error */) > 0; }\n    /// When true, this node type doesn't correspond to a user-declared\n    /// named node, for example because it is used to cache repetition.\n    get isAnonymous() { return (this.flags & 8 /* NodeFlag.Anonymous */) > 0; }\n    /// Returns true when this node's name or one of its\n    /// [groups](#common.NodeProp^group) matches the given string.\n    is(name) {\n        if (typeof name == 'string') {\n            if (this.name == name)\n                return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node or\n    /// [group](#common.NodeProp^group) names. Often useful with\n    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    /// names, separated by spaces, in a single property name to map\n    /// multiple node names to a single value.\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => {\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found)\n                    return found;\n            }\n        };\n    }\n}\n/// An empty dummy node type to use when no actual type is available.\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a numeric array. Each parser\n/// [has](#lr.LRParser.nodeSet) a node set, and [tree\n/// buffers](#common.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536) node\n/// types in it, so that the ids fit into 16-bit typed array slots.\nclass NodeSet {\n    /// Create a set with the given types. The `id` property of each\n    /// type should correspond to its position within the array.\n    constructor(\n    /// The node types in this set, by id.\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /// Create a copy of this set with some node properties added. The\n    /// arguments to this method can be created with\n    /// [`NodeProp.add`](#common.NodeProp.add).\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let add = source(type);\n                if (add) {\n                    if (!newProps)\n                        newProps = Object.assign({}, type.props);\n                    newProps[add[0].id] = add[1];\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/// Options that control iteration. Can be combined with the `|`\n/// operator to enable multiple ones.\nvar IterMode;\n(function (IterMode) {\n    /// When enabled, iteration will only visit [`Tree`](#common.Tree)\n    /// objects, not nodes packed into\n    /// [`TreeBuffer`](#common.TreeBuffer)s.\n    IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n    /// Enable this to make iteration include anonymous nodes (such as\n    /// the nodes that wrap repeated grammar constructs into a balanced\n    /// tree).\n    IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n    /// By default, regular [mounted](#common.NodeProp^mounted) nodes\n    /// replace their base node in iteration. Enable this to ignore them\n    /// instead.\n    IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n    /// This option only applies in\n    /// [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n    /// library to not enter mounted overlays if one covers the given\n    /// position.\n    IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the [`TreeCursor`](#common.TreeCursor) or\n/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\n/// a view on some part of this data structure, and can be used to\n/// move around to adjacent nodes.\nclass Tree {\n    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    constructor(\n    /// The type of the top node.\n    type, \n    /// This node's child nodes.\n    children, \n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    positions, \n    /// The total length of this tree\n    length, \n    /// Per-node [node props](#common.NodeProp) to associate with this node.\n    props) {\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /// @internal\n        this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)\n                this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /// @internal\n    toString() {\n        let mounted = this.prop(NodeProp.mounted);\n        if (mounted && !mounted.overlay)\n            return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children) {\n            let str = ch.toString();\n            if (str) {\n                if (children)\n                    children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children :\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /// Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    /// the tree. Mode can be used to [control](#common.IterMode) which\n    /// nodes the cursor visits.\n    cursor(mode = 0) {\n        return new TreeCursor(this.topNode, mode);\n    }\n    /// Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    /// at the given position and side (see\n    /// [`moveTo`](#common.TreeCursor.moveTo).\n    cursorAt(pos, side = 0, mode = 0) {\n        let scope = CachedNode.get(this) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n        return cursor;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) object for the top of the\n    /// tree.\n    get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /// Get the [syntax node](#common.SyntaxNode) at the given position.\n    /// If `side` is -1, this will move into nodes that end at the\n    /// position. If 1, it'll move into nodes that start at the\n    /// position. With 0, it'll only enter nodes that cover the position\n    /// from both sides.\n    ///\n    /// Note that this will not enter\n    /// [overlays](#common.MountedTree.overlay), and you often want\n    /// [`resolveInner`](#common.Tree.resolveInner) instead.\n    resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /// Like [`resolve`](#common.Tree.resolve), but will enter\n    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    /// pointing into the innermost overlaid tree at the given position\n    /// (with parent links going through all parent structure, including\n    /// the host trees).\n    resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /// Iterate over the tree and its children, calling `enter` for any\n    /// node that touches the `from`/`to` region (if given) before\n    /// running over such a node's children, and `leave` (if given) when\n    /// leaving the node. When `enter` returns `false`, that node will\n    /// not have its children iterated over (or `leave` called).\n    iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        for (let c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous);;) {\n            let entered = false;\n            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {\n                if (c.firstChild())\n                    continue;\n                entered = true;\n            }\n            for (;;) {\n                if (entered && leave && !c.type.isAnonymous)\n                    leave(c);\n                if (c.nextSibling())\n                    break;\n                if (!c.parent())\n                    return;\n                entered = true;\n            }\n        }\n    }\n    /// Get the value of the given [node prop](#common.NodeProp) for this\n    /// node. Works with both per-node and per-type props.\n    prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    /// format that can be passed to the [`Tree`](#common.Tree)\n    /// constructor.\n    get propValues() {\n        let result = [];\n        if (this.props)\n            for (let id in this.props)\n                result.push([+id, this.props[id]]);\n        return result;\n    }\n    /// Balance the direct children of this tree, producing a copy of\n    /// which may have children grouped into subtrees with type\n    /// [`NodeType.none`](#common.NodeType^none).\n    balance(config = {}) {\n        return this.children.length <= 8 /* Balance.BranchFactor */ ? this :\n            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n    }\n    /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n    static build(data) { return buildTree(data); }\n}\n/// The empty tree\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it).\nclass TreeBuffer {\n    /// Create a tree buffer.\n    constructor(\n    /// The buffer's content.\n    buffer, \n    /// The total length of the group of nodes in the buffer.\n    length, \n    /// The node set used in this buffer.\n    set) {\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /// @internal\n    get type() { return NodeType.none; }\n    /// @internal\n    toString() {\n        let result = [];\n        for (let index = 0; index < this.buffer.length;) {\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /// @internal\n    childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError)\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index)\n            return result;\n        let children = [];\n        while (index < endIndex) {\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /// @internal\n    findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0)\n                    break;\n            }\n        }\n        return pick;\n    }\n    /// @internal\n    slice(startI, endI, from) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI), len = 0;\n        for (let i = startI, j = 0; i < endI;) {\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            let to = copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n            len = Math.max(len, to);\n        }\n        return new TreeBuffer(copy, len, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch (side) {\n        case -2 /* Side.Before */: return from < pos;\n        case -1 /* Side.AtOrBefore */: return to >= pos && from < pos;\n        case 0 /* Side.Around */: return from < pos && to > pos;\n        case 1 /* Side.AtOrAfter */: return from <= pos && to > pos;\n        case 2 /* Side.After */: return to > pos;\n        case 4 /* Side.DontCare */: return true;\n    }\n}\nfunction enterUnfinishedNodesBefore(node, pos) {\n    let scan = node.childBefore(pos);\n    while (scan) {\n        let last = scan.lastChild;\n        if (!last || last.to != scan.to)\n            break;\n        if (last.type.isError && last.from == last.to) {\n            node = scan;\n            scan = last.prevSibling;\n        }\n        else {\n            scan = last;\n        }\n    }\n    return node;\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while (node.from == node.to ||\n        (side < 1 ? node.from >= pos : node.from > pos) ||\n        (side > -1 ? node.to <= pos : node.to < pos)) {\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent)\n            return node;\n        node = parent;\n    }\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays)\n        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\n            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)\n                node = parent;\n        }\n    for (;;) {\n        let inner = node.enter(pos, side, mode);\n        if (!inner)\n            return node;\n        node = inner;\n    }\n}\nclass TreeNode {\n    constructor(_tree, from, \n    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent) {\n        this._tree = _tree;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() { return this._tree.type; }\n    get name() { return this._tree.type.name; }\n    get to() { return this.from + this._tree.length; }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for (let parent = this;;) {\n            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n                let next = children[i], start = positions[i] + parent.from;\n                if (!checkSide(side, pos, start, start + next.length))\n                    continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & IterMode.ExcludeBuffers)\n                        continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1)\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                }\n                else if ((mode & IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {\n                    let mounted;\n                    if (!(mode & IterMode.IgnoreMounts) &&\n                        next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)\n                        return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return (mode & IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner\n                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if ((mode & IterMode.IncludeAnonymous) || !parent.type.isAnonymous)\n                return null;\n            if (parent.index >= 0)\n                i = parent.index + dir;\n            else\n                i = dir < 0 ? -1 : parent._parent._tree.children.length;\n            parent = parent._parent;\n            if (!parent)\n                return null;\n        }\n    }\n    get firstChild() { return this.nextChild(0, 1, 0, 4 /* Side.DontCare */); }\n    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */); }\n    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* Side.After */); }\n    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */); }\n    enter(pos, side, mode = 0) {\n        let mounted;\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay) {\n                if ((side > 0 ? from <= rPos : from < rPos) &&\n                    (side < 0 ? to >= rPos : to > rPos))\n                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, mode);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while (val.type.isAnonymous && val._parent)\n            val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;\n    }\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    get tree() { return this._tree; }\n    toTree() { return this._tree; }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    /// @internal\n    toString() { return this._tree.toString(); }\n    get node() { return this; }\n    matchContext(context) { return matchNodeContext(this, context); }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor(), result = [];\n    if (!cur.firstChild())\n        return result;\n    if (before != null)\n        while (!cur.type.is(before))\n            if (!cur.nextSibling())\n                return result;\n    for (;;) {\n        if (after != null && cur.type.is(after))\n            return result;\n        if (cur.type.is(type))\n            result.push(cur.node);\n        if (!cur.nextSibling())\n            return after == null ? result : [];\n    }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n    for (let p = node.parent; i >= 0; p = p.parent) {\n        if (!p)\n            return false;\n        if (!p.type.isAnonymous) {\n            if (context[i] && context[i] != p.name)\n                return false;\n            i--;\n        }\n    }\n    return true;\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start) {\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode {\n    get name() { return this.type.name; }\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\n    constructor(context, _parent, index) {\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() { return this.child(1, 0, 4 /* Side.DontCare */); }\n    get lastChild() { return this.child(-1, 0, 4 /* Side.DontCare */); }\n    childAfter(pos) { return this.child(1, pos, 2 /* Side.After */); }\n    childBefore(pos) { return this.child(-1, pos, -2 /* Side.Before */); }\n    enter(pos, side, mode = 0) {\n        if (mode & IterMode.ExcludeBuffers)\n            return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n            return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart)\n            return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n    }\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    get tree() { return null; }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1];\n            children.push(buffer.slice(startI, endI, from));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    /// @internal\n    toString() { return this.context.buffer.childString(this.index); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    get node() { return this; }\n    matchContext(context) { return matchNodeContext(this, context); }\n}\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nclass TreeCursor {\n    /// Shorthand for `.type.name`.\n    get name() { return this.type.name; }\n    /// @internal\n    constructor(node, \n    /// @internal\n    mode = 0) {\n        this.mode = mode;\n        /// @internal\n        this.buffer = null;\n        this.stack = [];\n        /// @internal\n        this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        }\n        else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for (let n = node._parent; n; n = n._parent)\n                this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    yieldNode(node) {\n        if (!node)\n            return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    yield(node) {\n        if (!node)\n            return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /// @internal\n    toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /// @internal\n    enterChild(dir, pos, side) {\n        if (!this.buffer)\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0)\n            return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /// Move the cursor to this node's first child. When this returns\n    /// false, the node has no child, and the cursor has not been moved.\n    firstChild() { return this.enterChild(1, 0, 4 /* Side.DontCare */); }\n    /// Move the cursor to this node's last child.\n    lastChild() { return this.enterChild(-1, 0, 4 /* Side.DontCare */); }\n    /// Move the cursor to the first child that ends after `pos`.\n    childAfter(pos) { return this.enterChild(1, pos, 2 /* Side.After */); }\n    /// Move to the last child that starts before `pos`.\n    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Side.Before */); }\n    /// Move the cursor to the child around `pos`. If side is -1 the\n    /// child may end at that position, when 1 it may start there. This\n    /// will also enter [overlaid](#common.MountedTree.overlay)\n    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    /// set to false.\n    enter(pos, side, mode = this.mode) {\n        if (!this.buffer)\n            return this.yield(this._tree.enter(pos, side, mode));\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /// Move to the node's parent node, if this isn't the top node.\n    parent() {\n        if (!this.buffer)\n            return this.yieldNode((this.mode & IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);\n        if (this.stack.length)\n            return this.yieldBuf(this.stack.pop());\n        let parent = (this.mode & IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /// @internal\n    sibling(dir) {\n        if (!this.buffer)\n            return !this._tree._parent ? false\n                : this.yield(this._tree.index < 0 ? null\n                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart)\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n        }\n        else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n                return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;\n    }\n    /// Move to this node's next sibling, if any.\n    nextSibling() { return this.sibling(1); }\n    /// Move to this node's previous sibling, if any.\n    prevSibling() { return this.sibling(-1); }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length)\n                    return false;\n            }\n            else {\n                for (let i = 0; i < this.index; i++)\n                    if (buffer.buffer.buffer[i + 3] < this.index)\n                        return false;\n            }\n            ({ index, parent } = buffer);\n        }\n        else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for (; parent; { index, _parent: parent } = parent) {\n            if (index > -1)\n                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {\n                    let child = parent._tree.children[i];\n                    if ((this.mode & IterMode.IncludeAnonymous) ||\n                        child instanceof TreeBuffer ||\n                        !child.type.isAnonymous ||\n                        hasChild(child))\n                        return false;\n                }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */))\n            return true;\n        for (;;) {\n            if (this.sibling(dir))\n                return true;\n            if (this.atLastNode(dir) || !this.parent())\n                return false;\n        }\n    }\n    /// Move to the next node in a\n    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n    /// traversal, going from a node to its first child or, if the\n    /// current node is empty or `enter` is false, its next sibling or\n    /// the next sibling of the first parent node that has one.\n    next(enter = true) { return this.move(1, enter); }\n    /// Move to the next node in a last-to-first pre-order traveral. A\n    /// node is followed by its last child or, if it has none, its\n    /// previous sibling or the previous sibling of the first parent\n    /// node that has one.\n    prev(enter = true) { return this.move(-1, enter); }\n    /// Move the cursor to the innermost node that covers `pos`. If\n    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    /// it will enter nodes that start at `pos`.\n    moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while (this.from == this.to ||\n            (side < 1 ? this.from >= pos : this.from > pos) ||\n            (side > -1 ? this.to <= pos : this.to < pos))\n            if (!this.parent())\n                break;\n        // Then scan down into child nodes as far as possible\n        while (this.enterChild(1, pos, side)) { }\n        return this;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    /// position.\n    get node() {\n        if (!this.buffer)\n            return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n                for (let c = cache; c; c = c._parent)\n                    if (c.index == index) {\n                        if (index == this.index)\n                            return c;\n                        result = c;\n                        depth = d + 1;\n                        break scan;\n                    }\n                index = this.stack[--d];\n            }\n        }\n        for (let i = depth; i < this.stack.length; i++)\n            result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /// Get the [tree](#common.Tree) that represents the current node, if\n    /// any. Will return null when the node is in a [tree\n    /// buffer](#common.TreeBuffer).\n    get tree() {\n        return this.buffer ? null : this._tree._tree;\n    }\n    /// Iterate over the current node and all its descendants, calling\n    /// `enter` when entering a node and `leave`, if given, when leaving\n    /// one. When `enter` returns `false`, any children of that node are\n    /// skipped, and `leave` isn't called for it.\n    iterate(enter, leave) {\n        for (let depth = 0;;) {\n            let mustLeave = false;\n            if (this.type.isAnonymous || enter(this) !== false) {\n                if (this.firstChild()) {\n                    depth++;\n                    continue;\n                }\n                if (!this.type.isAnonymous)\n                    mustLeave = true;\n            }\n            for (;;) {\n                if (mustLeave && leave)\n                    leave(this);\n                mustLeave = this.type.isAnonymous;\n                if (this.nextSibling())\n                    break;\n                if (!depth)\n                    return;\n                this.parent();\n                depth--;\n                mustLeave = true;\n            }\n        }\n    }\n    /// Test whether the current node matches a given contexta sequence\n    /// of direct parent node names. Empty strings in the context array\n    /// are treated as wildcards.\n    matchContext(context) {\n        if (!this.buffer)\n            return matchNodeContext(this.node, context);\n        let { buffer } = this.buffer, { types } = buffer.set;\n        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {\n            if (d < 0)\n                return matchNodeContext(this.node, context, i);\n            let type = types[buffer.buffer[this.stack[d]]];\n            if (!type.isAnonymous) {\n                if (context[i] && context[i] != type.name)\n                    return false;\n                i--;\n            }\n        }\n        return true;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead;\n        while (size < 0) {\n            cursor.next();\n            if (size == -1 /* SpecialRecord.Reuse */) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            }\n            else if (size == -3 /* SpecialRecord.ContextChange */) { // Context change\n                contextHash = id;\n                return;\n            }\n            else if (size == -4 /* SpecialRecord.LookAhead */) {\n                lookAhead = id;\n                return;\n            }\n            else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while (cursor.pos > endPos) {\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                }\n                else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)\n                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            }\n            else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function makeBalanced(type) {\n        return (children, positions, length) => {\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length)\n                    return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead))\n                    lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n        let localChildren = [], localPositions = [];\n        while (children.length > i) {\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead = 0, props) {\n        if (contextHash) {\n            let pair = [NodeProp.contextHash, contextHash];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        if (lookAhead > 25) {\n            let pair = [NodeProp.lookAhead, lookAhead];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = { size: 0, start: 0, skip: 0 };\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* SpecialRecord.ContextChange */)\n                        localSkipped += 4;\n                    else\n                        break scan;\n                }\n                else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while (cursor.pos > endPos)\n                    index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        else if (size == -3 /* SpecialRecord.ContextChange */) {\n            contextHash = id;\n        }\n        else if (size == -4 /* SpecialRecord.LookAhead */) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)\n        return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children) {\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(\n// The type the balanced tree's inner nodes.\nbalanceType, \n// The direct children and their positions\nchildren, positions, \n// The index range in children/positions to use\nfrom, to, \n// The start position of the nodes, relative to their parent.\nstart, \n// Length of the outer node\nlength, \n// Function to build the top node of the balanced tree\nmkTop, \n// Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for (let i = from; i < to; i++)\n        total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil((total * 1.5) / 8 /* Balance.BranchFactor */);\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for (; i < to; i++) {\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild)\n                    break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/// Provides a way to associate values with pieces of trees. As long\n/// as that part of the tree is reused, the associated values can be\n/// retrieved from an updated tree.\nclass NodeWeakMap {\n    constructor() {\n        this.map = new WeakMap();\n    }\n    setBuffer(buffer, index, value) {\n        let inner = this.map.get(buffer);\n        if (!inner)\n            this.map.set(buffer, inner = new Map);\n        inner.set(index, value);\n    }\n    getBuffer(buffer, index) {\n        let inner = this.map.get(buffer);\n        return inner && inner.get(index);\n    }\n    /// Set the value for this syntax node.\n    set(node, value) {\n        if (node instanceof BufferNode)\n            this.setBuffer(node.context.buffer, node.index, value);\n        else if (node instanceof TreeNode)\n            this.map.set(node.tree, value);\n    }\n    /// Retrieve value for this syntax node, if it exists in the map.\n    get(node) {\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)\n            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /// Set the value for the node that a cursor currently points to.\n    cursorSet(cursor, value) {\n        if (cursor.buffer)\n            this.setBuffer(cursor.buffer.buffer, cursor.index, value);\n        else\n            this.map.set(cursor.tree, value);\n    }\n    /// Retrieve the value for the node that a cursor currently points\n    /// to.\n    cursorGet(cursor) {\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n}\n\n/// Tree fragments are used during [incremental\n/// parsing](#common.Parser.startParse) to track parts of old trees\n/// that can be reused in a new parse. An array of fragments is used\n/// to track regions of an old tree whose nodes might be reused in new\n/// parses. Use the static\n/// [`applyChanges`](#common.TreeFragment^applyChanges) method to\n/// update fragments for document changes.\nclass TreeFragment {\n    /// Construct a tree fragment. You'll usually want to use\n    /// [`addTree`](#common.TreeFragment^addTree) and\n    /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n    /// calling this directly.\n    constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    from, \n    /// The end of the unchanged range.\n    to, \n    /// The tree that this fragment is based on.\n    tree, \n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    offset, openStart = false, openEnd = false) {\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);\n    }\n    /// Whether the start of the fragment represents the start of a\n    /// parse, or the end of a change. (In the second case, it may not\n    /// be safe to reuse some nodes at the start, depending on the\n    /// parsing algorithm.)\n    get openStart() { return (this.open & 1 /* Open.Start */) > 0; }\n    /// Whether the end of the fragment represents the end of a\n    /// full-document parse, or the start of a change.\n    get openEnd() { return (this.open & 2 /* Open.End */) > 0; }\n    /// Create a set of fragments from a freshly parsed tree, or update\n    /// an existing set of fragments by replacing the ones that overlap\n    /// with a tree with content from the new tree. When `partial` is\n    /// true, the parse is treated as incomplete, and the resulting\n    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    /// true.\n    static addTree(tree, fragments = [], partial = false) {\n        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n        for (let f of fragments)\n            if (f.to > tree.length)\n                result.push(f);\n        return result;\n    }\n    /// Apply a set of edits to an array of fragments, removing or\n    /// splitting fragments as necessary to remove edited ranges, and\n    /// adjusting offsets for fragments that moved.\n    static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length)\n            return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for (let cI = 0, pos = 0, off = 0;; cI++) {\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap)\n                while (nextF && nextF.from < nextPos) {\n                    let cut = nextF;\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                    }\n                    if (cut)\n                        result.push(cut);\n                    if (nextF.to > nextPos)\n                        break;\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\n                }\n            if (!nextC)\n                break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/// A superclass that parsers should extend.\nclass Parser {\n    /// Start a parse, returning a [partial parse](#common.PartialParse)\n    /// object. [`fragments`](#common.TreeFragment) can be passed in to\n    /// make the parse incremental.\n    ///\n    /// By default, the entire input is parsed. You can pass `ranges`,\n    /// which should be a sorted array of non-empty, non-overlapping\n    /// ranges, to parse only those ranges. The tree returned in that\n    /// case will start at `ranges[0].from`.\n    startParse(input, fragments, ranges) {\n        if (typeof input == \"string\")\n            input = new StringInput(input);\n        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /// Run a full parse, returning the resulting tree.\n    parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for (;;) {\n            let done = parse.advance();\n            if (done)\n                return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string) {\n        this.string = string;\n    }\n    get length() { return this.string.length; }\n    chunk(from) { return this.string.slice(from); }\n    get lineChunks() { return false; }\n    read(from, to) { return this.string.slice(from, to); }\n}\n\n/// Create a parse wrapper that, after the inner parse completes,\n/// scans its tree for mixed language regions with the `nest`\n/// function, runs the resulting [inner parses](#common.NestedParse),\n/// and then [mounts](#common.NodeProp^mounted) their results onto the\n/// tree.\nfunction parseMixed(nest) {\n    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target, ranges) {\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n        this.ranges = ranges;\n    }\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev) {\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({ perNode: true });\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges) {\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done)\n                return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null)\n                for (let inner of this.inner)\n                    inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null)\n                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse)\n            return 0;\n        let pos = this.input.length;\n        for (let i = this.innerDone; i < this.inner.length; i++) {\n            if (this.inner[i].ranges[0].from < pos)\n                pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse)\n            this.baseParse.stopAt(pos);\n        else\n            for (let i = this.innerDone; i < this.inner.length; i++)\n                this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {\n            let enter = true, range;\n            if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match)\n                        for (let r of match.mount.overlay) {\n                            let from = r.from + match.pos, to = r.to + match.pos;\n                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))\n                                overlay.ranges.push({ from, to });\n                        }\n                }\n                enter = false;\n            }\n            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Cover.Full */;\n            }\n            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {\n                if (!cursor.tree)\n                    materialize(cursor);\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                }\n                else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);\n                    if (ranges.length)\n                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));\n                    if (!nest.overlay)\n                        enter = false;\n                    else if (ranges.length)\n                        covered = { ranges, depth: 0, prev: covered };\n                }\n            }\n            else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true)\n                    range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to)\n                    overlay.ranges.push(range);\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay)\n                    overlay.depth++;\n                if (covered)\n                    covered.depth++;\n            }\n            else {\n                for (;;) {\n                    if (cursor.nextSibling())\n                        break;\n                    if (!cursor.parent())\n                        break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length)\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth)\n                        covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered) {\n        if (range.from >= to)\n            break;\n        if (range.to > from)\n            return range.from <= from && range.to >= to ? 2 /* Cover.Full */ : 1 /* Cover.Partial */;\n    }\n    return 0 /* Cover.None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1];\n        nodes.push(buf.slice(startI, endI, from));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, depth = 0;\n    // Scan up to the nearest tree\n    do {\n        cursor.parent();\n        depth++;\n    } while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let i = 0, base = cursor.tree, off = 0;\n    for (;; i++) {\n        off = base.positions[i] + cursor.from;\n        if (off <= node.from && off + base.children[i].length >= node.to)\n            break;\n    }\n    let buf = base.children[i], b = buf.buffer;\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length) {\n        let i = startI;\n        while (b[i + 2] + off <= node.from)\n            i = b[i + 3];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, i, children, positions, innerOffset);\n        let from = b[i + 1], to = b[i + 2];\n        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;\n        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);\n    // Move the cursor back to the target node\n    for (let d = 0; d <= depth; d++)\n        cursor.childAfter(node.from);\n}\nclass StructureCursor {\n    constructor(root, offset) {\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while (!this.done && cursor.from < p) {\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\n            else if (!cursor.next(false))\n                this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for (let tree = this.cursor.tree;;) {\n                if (tree == cursor.tree)\n                    return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)\n                    tree = tree.children[0];\n                else\n                    break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments) {\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        }\n        else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while (this.curFrag && node.from >= this.curTo)\n            this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        }\n        else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for (let i = this.fragI; i < this.fragments.length; i++) {\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to)\n                            break;\n                        if (frag.tree == this.curFrag.tree)\n                            result.push({\n                                frag,\n                                pos: pos.from - frag.offset,\n                                mount\n                            });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for (let i = 1, j = 0; i < outer.length; i++) {\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for (; j < current.length; j++) {\n            let r = current[j];\n            if (r.from >= gapTo)\n                break;\n            if (r.to <= gapFrom)\n                continue;\n            if (!copy)\n                current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo)\n                    copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            }\n            else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            }\n            else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for (;;) {\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end)\n                result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9)\n            break;\n        if (nextA == pos) {\n            if (!inA)\n                inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB)\n                inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts) {\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for (let i = 0, pos = from;; i++) {\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos)\n                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n                if (last)\n                    break;\n                pos = changes[i].to;\n            }\n        }\n        else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n        }\n    }\n    return result;\n}\n\nexport { DefaultBufferLength, IterMode, MountedTree, NodeProp, NodeSet, NodeType, NodeWeakMap, Parser, Tree, TreeBuffer, TreeCursor, TreeFragment, parseMixed };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}